# C++ 基本介绍
C++ 是一种静态类型、编译型、通用且支持面向对象、过程化及泛型编程的编程语言，它由 C 语言扩展而来，以其高性能和灵活性著称，常用于开发操作系统、游戏引擎、大型应用程序、嵌入式系统等领域。C++ 增加了类、模板、异常处理等特性，同时保留了 C 语言的强大底层控制能力，能够满足广泛的开发需求。

## 起源与发展
C++ 最初由 Bjarne Stroustrup 在 1979 年于贝尔实验室开发。它是在 C 语言的基础上进行扩展和改进的，最初命名为“带类的C”，后于1983 年更名为 C++。

## 主要特点
- 支持多种编程范式：它不仅支持过程化编程，还支持面向对象编程（如类、对象、继承、多态）和泛型编程。
- 高级与低级特性兼备：C++ 兼具高级语言的抽象能力和低级语言的硬件控制能力，被认为是一种中级语言。
- 高效性和灵活性：C++ 以其卓越的性能和高度的灵活性而闻名，适合对性能要求极高的应用。
- 静态类型和编译型：它在编译时进行类型检查，并需要将源代码编译为机器码才能执行。
跨平台性：C++ 可以在多种操作系统上运行，包括 Windows、macOS 和 Linux（Unix）。

## 典型应用场景
- 操作系统开发：许多操作系统，如 Windows，在很大程度上是用 C++ 编写的。
- 游戏开发：C++ 的高性能使其成为开发大型游戏引擎和游戏的理想选择。
- 嵌入式系统：其对硬件的直接控制能力适用于嵌入式系统的开发。
- 桌面应用程序：用于构建复杂的桌面应用程序。
- 服务器应用和后台系统：在构建高性能的服务器端应用和数据库方面也发挥着重要作用。

# HelloWorld
目录结构如下：
```bash
../../xcpp001helloword
├── build
│   └── helloword
└── src
    └── helloworld.cpp

3 directories, 2 files
```

代码：
```c++
#include <iostream>
#include <unistd.h> // for pause() function on Unix-like systems
using namespace std;

int main()
{
    // 这里表示单行注释
    /* 这里表示多行注释
        多行注释可以换行
    */


    // std 表示命名空间namespace，在一个文件中指定命名空间，可以避免冲突
    // :: 是作用域解析运算符，表示使用某个命名空间下的成员
    std::cout << "hello, world" << std::endl;
    cout << "hello, world" << endl; // 因为上面使用了命名空间 std， 所以这里可以省略 std::


    // 提示用户输入姓名
    std::cout << "请输入您的姓名：" << endl;
    // 用一个变量来保存键盘的输入信息
    string name; // string 是C++标准库中表示字符串的类型
    std::cin >> name; // 从键盘输入信息，并保存到变量 name 中
    // 输出欢迎信息
    std::cout << "欢迎您，" << name << "!" << std::endl;


    // system("pause"); // windows系统下让程序在结束前暂停，方便查看输出结果
    pause(); // ctrl+c 结束程序，适用于Unix-like系统
    // cin.get(); // 让程序在结束前暂停，等待用户按下回车键
    // return 0; // C++ main function will return 0 by default, so this line is optional.
}
```
编译：
```bash
g++ -std=c++11 helloworld.cpp -o ../build/helloword
```
执行：
```bash
../build/helloword
```

# 函数
## 调用函数
代码结构：
```bash
│       └── helloworld.cpp
└── xcpp002func
    ├── build
    │   └── main
    └── src
        ├── main.cpp
        └── welcome.cpp

7 directories, 5 files
```
main.cpp
```c++
#include <iostream> // for std::cout, std::cin and std::endl;
#include <unistd.h> // for pause()

// function declaration
void welcome();

// function definition
void greet() {
    std::cout << "please input your name: " << std::endl;
    std::string name;
    std::cin >> name;
    std::cout << "hello, " << name << std::endl;

    return;
}

/*
main function
*/
int main() {
    greet();

    welcome();
    // // keep the console window open in debug mode
    // // use two std::cin.get() to wait for the second enter key
    // std::cin.get();
    // std::cin.get();

    pause(); // ctrl + c to exit
    return 0;

}
```
welcome.cpp

```c++
#include <iostream>

void welcome() {
    std::cout << "please input your name: " << std::endl;
    std::string name;
    std::cin >> name;
    std::cout << "hello, " << name << std::endl;
    return;
}
```
编译代码
```bash
g++ -std=c++11 main.cpp welcome.cpp -o ../build/main
```
run
```c++
../build/main
```

# 变量和数据类型
## 变量声明

变量的声明和赋值
```c++
// 数据类型 变量名;
int a;
```

## 标识符
标识符由字母、数字和下划线组成，但是不能以数字开头，标识符是大小写敏感的，长度不限。

C++ 中对变量命名有一些要求和约定俗成的规范：
1. 不能使用C++关键字
2. 不能用连续两个下划线开头，也不能以下划线加大写字母开头，这些被C++保留给标准库使用
3. 函数体外的标识符，不能以下划线开头
4. 要尽量有实际意义
5. 变量名一般使用小写字母
6. 自定义类名一般以大写字母开头
7. 如果包含多个单词，一般用下划线分隔，或者将后面的单词首字母大写

C++关键字：
| 关键字     | 关键字       | 关键字    | 关键字           | 关键字   |
| ---------- | ------------ | --------- | ---------------- | -------- |
| alignas    | continue     | friend    | register         | true     |
| alignof    | decltype     | goto      | reinterpret_cast | try      |
| asm        | default      | if        | return           | typedef  |
| auto       | delete       | inline    | short            | typeid   |
| bool       | do           | int       | signed           | typename |
| break      | double       | long      | sizeof           | union    |
| case       | dynamic_cast | mutable   | static           | unsigned |
| catch      | else         | namespace | static_assert    | using    |
| char       | enum         | new       | static_cast      | virtual  |
| char16_t   | explicit     | noexcept  | struct           | void     |
| char32_t   | export       | nullptr   | switch           | volatile |
| class      | extern       | operator  | template         | wchar_t  |
| const      | false        | private   | this             | while    |
| constexpr  | float        | protected | thread_local     | throw    |
| const_cast | for          | public    |                  |          |

C++ 中使用的一些运算操作符的替代名：
| 运算符 | 运算符 | 运算符 | 运算符 | 运算符 | 运算符 |
| ------ | ------ | ------ | ------ | ------ | ------ |
| and    | bitand | compl  | not_eq | or_eq  | xor_eq |
| and_eq | bitor  | not    | or     | xor    |        |

## 作用域
C++ 中全局变量在所有函数外部声明，作用域覆盖整个程序，生命周期从程序开始到结束，存储在全局存储区；局部变量在函数或代码块内部声明，作用域仅限于其定义的{}内，生命周期仅限于其作用域内，存储在栈区。两者主要区别在于作用域、生命周期和存储位置
```c++
#include <iostream>

// 全局变量声明时可以不用初始化，使用默认值
int number; // 全局变量

int main() {
    // variable declaration
    int a = 1, b;
    std::cout << "a = " << a << std::endl;
    b = 10;
    std::cout << "b = " << b << std::endl;
    b = 25;
    std::cout << "b = " << b << std::endl;
    
    // 定义局部变量；局部变量声明时，或者后面必须初始化；
    // 否则使用未初始化的局部变量会导致不可预期的结果
    int number;
    number = 20;
    std::cout << "number = " << number << std::endl;
    std::cout << "global number = " << ::number << std::endl; // 访问全局变量

}
```

## 常量
保存的数据不能更改，这种特殊的变量被叫做“常量”，C++中有两种方式可以定义常量：
1. 使用符号常量
这种方式是在文件头用#define来定义常量，也叫作“宏定义”
```c++
// 没有数据类型的定义
// 宏定义常量约定用全大写
#define ZERO 0
```
跟 #include 一样，“#”号开头的语句都是“预处理语句”，在编译之前，预处理器会查找程序中所有的“ZERO”，并把它替换成0，这种宏定义的方式是保留的C语言特性，在C++中一般不推荐。
2. 使用const限定符
这种方式跟定义一个变量是一样的，只需要在变量的数据类型前再加上一个 const 关键字，这被称为"限定符"
```c++
// 定义常量；声明时必须初始化
// 约定首字母大写
const int Zero = 0;
 
// 不能修改常量值
Zero = 10; // error
```

## 基本数据类型
C++支持丰富的数据类型，它内置了一套基本数据类型，也为我们提供了自定义类型的机制。

基本数据类型主要包括算术类型和空类型（void）。算术类型包含整型和浮点型，空类型不对应具体的值，只用在一些特定的场合，比如一个函数如果不返回任何只，可以用 void 作为它的返回类型。

### 整型
计算机中所有数据都是以二进制 0，1 来表示的，每个叫做一位 bit，而计算机可寻址的内存最小单元是 8 位，即一个字节 byte。

C++ 定义了多种整数类型，包括 char, short, int, long, C++11 新增了 long long 类型，此外，特殊的布尔类型  bool 本质上也是整型。

| 类型      | 含义     | 最小尺寸（具体依据操作系统）   |
| --------- | -------- | ------------------------------ |
| bool      | 布尔类型 | 未定义                         |
| char      | 字符     | 8位，1个字节                   |
| short     | 短整型   | 16位，最小2字节                |
| int       | 整型     | 16位，最小2字节，不能比short短 |
| long      | 长整型   | 32位，最小4字节，不能比int短   |
| long long | 长整型   | 64位，至少8字节，不能比long 短 |

C++ 中对不同整型类型占据的长度定义比较灵活，这样不同的计算机平台就可以有自己的实现（这根C是一样的）。

现在一般系统中，short和long 都选择最小长度，也就是short占2个字节， long占4个字节， long long 占8个字节。但是 int 则有不同的选择，一般使用的电脑操作系统（windows7, windows10, macos等）的实现中，int都是4字节的。

short 表示的数有 $2^{16}=65536$个，考虑正负，范围是 -32768 $\sim$ 32768; 而 int 能表示的数范围则为 $-2^{31} \sim 2^{31} - 1$，大概是20亿。

### 无符号整型
整型默认是可正可负的，如果只想表示正数和0，那么所能表示的范围就会增大一倍。如 16 位的 short 类型，不考虑负数，表示范围是 0 $\sim$ 65535。C++ 中，short, int, long, long long 都有各自的无符号版本。只需要在定义类型时前面增加上 unsigned

需要注意，当数值超出了整型表示的范围，程序本身并不会报错，而是会让数值回到能表示的最小值，这种情况叫做“数据溢出”或者“算术溢出”。

由于整型的类型太多，在实际应用中使用整型可以只考虑三个原则：
- 一般的整数计算，全部用 int；
- 如果数值超出了 int 的表示范围，用 long long;
- 确定数值不可能为负时，用无符号类型（如统计人数、销售额等）

```c++
#include <iostream>

int main() {
    short a = 10;
    std::cout << "a = " << a << std::endl;
    std::cout << "sizeof(a) = " << sizeof(a) << std::endl;
    std::cout << "sizeof a = " << sizeof a << std::endl;
    std::cout << "sizeof(short) = " << sizeof(short) << std::endl;
 
    int a2 = 10;
    std::cout << "a2 = " << a2 << std::endl;
    std::cout << "sizeof(a2) = " << sizeof(a2) << std::endl;
    std::cout << "sizeof a2 = " << sizeof a2 << std::endl;
    std::cout << "sizeof(int) = " << sizeof(int) << std::endl;

    long long a3 = 10;
    std::cout << "a3 = " << a3 << std::endl;
    std::cout << "sizeof(a3) = " << sizeof(a3) << std::endl;
    std::cout << "sizeof a3 = " << sizeof a3 << std::endl;
    std::cout << "sizeof(long long) = " << sizeof(long long) << std::endl;

    unsigned short a4 = 32768;
    std::cout << "a4 = " << a4 << std::endl;
    std::cout << "sizeof(a4) = " << sizeof(a4) << std::endl;
    std::cout << "sizeof a4 = " << sizeof a4 << std::endl;
    std::cout << "sizeof(unsigned short) = " << sizeof(unsigned short) << std::endl;
    
    return 0;
}
```

### char 类型
如果我们只需要处理很小的整数，也可以用另外一种特殊的整型类型 char，它通常只占一个字节。不过 char 类型一般并不用在整数计算，它更重要的用途是表示字符。

计算机底层的数据都是二进制位表示的，这用来表示一个整数当然没有问题，怎么表示字母呢，这就需要将字母、以及一些特殊符号对应到一个个的数字上，然后保存下来，这就是“编码”的过程。

最常用的字符编码集就是 ASCII 码，它用 0 $\sim$ 127 表示了128个字符，这包括了所有的大小写字母、数字、标点符号、特殊符号以及一些计算机的控制符。比如字母"A"的编码是65，数字字符"0"的编码是48.

在程序中如果使用 char 类型的变量，我们会发现，打印出来就是一个字符，而它的底层是一个整数，也可以做整数计算。

char 类型用来表示整数时，到底是有符号还是无符号呢，之前所有的整型，默认都是有符号的，而 char 并没有默认类型，而是需要 C++ 编译器根据需要自己决定。

所以把 char 当做小整数时，有两种显式的定义方式：signed char 和 unsigned char; 至于 char 定义出来的到底带不带符号，就看编译器的具体实现了。

另外，C++ 还对字符类型进行了“扩容”，提供了一种“宽字符”类型 wchar_t，其会在底层对应另一种类型（比如short或者int），具体占几个字节要看系统中的实现。

wchar_t 会随着具体实现而变化，不够稳定；所以在 C++11 新标准中，还为 Unicode 字符集提供了专门的扩展字符类型：char16_t 和 char32_t，分别长 16 位和 32 位。

| 类型     | 字符        | 位数 |
| -------- | ----------- | ---- |
| char     | 字符        | 8位  |
| wchar_t  | 宽字符      | 16位 |
| char16_t | Unicode字符 | 16位 |
| char32_t | Unicode字符 | 32位 |

```c++
#include <iostream>

int main() {
    char a = 65;
    char b = 'A';
    std::cout << "a: " << a << std::endl;
    std::cout << "b: " << b << std::endl;

    std::cout << "b + 1: " << (b + 1) << std::endl;
    char c = b + 1;
    std::cout << "c: " << c << std::endl;
    return 0;
}
```

### bool 类型
在程序中，往往需要针对某个条件做判断，结果只有两种：“成立”和“不成立”；如果用逻辑语言来描述，就是“真”和“假”。真值判断是二元的，所以在 C 语言中，可以很简单地用“1”表示“真”，用“0”表示“假”。

C++ 支持 C 语言中的这种定义，同时为了让代码更容易理解，引入了一种新的数据类型，布尔类型 bool（来自英国数学家布尔）。该类型只有两个取值：true 和 false，这样就可以非常明确地表示逻辑真假了。bool 类型通常占用 8 位。

```c++
#include <iostream>

int main() {
    bool b1 = true;
    bool b2 = false;
    std::cout << "b1: " << b1 << std::endl;
    std::cout << "b2: " << b2 << std::endl;

    std::cout << std::boolalpha; // Enable boolalpha to print bool as true/false
    std::cout << "b1 (boolalpha): " << b1 << std::endl;
    std::cout << "b2 (boolalpha): " << b2 << std::endl;

    std::cout << std::noboolalpha; // Disable boolalpah
    std::cout << "bool len: " << sizeof(bool) << std::endl;
    
    return 0;

}
```

可以看到，true 和 false 可以直接赋值给 bool 类型的变量，打印输出的时候，true 就是 1，false 就是 0，这跟 C 语言里的表示其实是一样的。

### 浮点类型
浮点类型用来表示小数，主要有单精度 float 和双精度 double 两种类型，double 的长度不会小于 float。通常，float 会占用 4 个字节（32位），而 double 会占用 8 个字节（64位）。此外，C++ 还提供了一种扩展的高精度类型 long double，一般会占 12 或 16 个字节。

除了一般的小数，在 C++ 中，还提供了另外一种浮点数的表示法，那就是科学计数法，也叫作“E表示法”。比如：5.98E24表示5.98 $\times 10^{24}$，9.11e-31 表示 $9.11\times 10^{-31}$.


### 字面值常量
给变量赋值的整数、小数等数据，就是显示定义的常量值，叫做“字面值常量”，literal。每个字面值常量需要计算机进行保存和处理，因此也有数据类型。字面值常量的写法形式和具体值，决定了他的类型。

#### 整型字面值常量
整型字面值常量是一个整数，比如 30，这里是十进制，但在计算机底层是二进制的。除了十进制，还支持协程八进制和十六进制的形式。以 0 开头的整数表示八进制数，以 0x 或 0X 开头的表示十六进制数，以 0b 或 0B 开头的表示二进制数，如

- 30，十进制数
- 0b1101，二进制数
- 0B1100，二进制数
- 036，八进制数（1 个位表示 3 个二进制 0,1）
- 0x1E，十六进制数（1 个位表示 4 个二进制 0,1）
- 0X1e，十六进制数

这几个数本质上都是十进制的30，在计算机底层都是一样的。

在 C++ 中，一个整型字面值，默认就是 int 类型，前提是数值在 int 能表示的范围。如果超出 int 范围，那就需要选择能够表示这个数的长度最小的那个类型。

具体来说，对于十进制的整型字面值常量，如果 int 不够那么选择 long；还不够，就选择  long long （不考虑无符号类型）；而八进制和十六进制字面值，则优先用无符号类型 unsigned int，不够的话选择 long，之后依次是 unsigned long, long long 和 unsigned long long.

一般在定义整型字面值常量时，会给它加上一个后缀，明确告诉计算机这个字面值是什么类型。

- 默认什么都不加，是 int 类型
- l 或 L，表示 long 类型
- ll 或 LL，表示 long long 类型
- u 或者 U，表示 unsigned 无符号类型

对于 l 和 L，一般用 L，避免跟数字 1 混淆；而 u 可以和 L, LL 组合。如 036L, 0x1EULL

#### 浮点型字面值常量
用小数或科学计数法表示的数给浮点类型变量赋值，这样的数就是浮点型字面值常量。浮点型字面值默认类型是 double，如果想要明确指定类型，也可以加上相应的后缀：

- f 或 F，表示 float 类型
- l 或 L，表示 long double 类型

因为浮点型字面值本身是小数或科学计数法，所以 L 不会跟整型的 long 类型混淆。

示例：3.14f, 1.25L, 3.79E-23

#### 字符字面值常量
字符就是常说的字母、单个数字、符号等，字面值用单引号括起来表示。字符字面值默认类型是 char，底层存储是整型。

示例：','，'A'，'2'

**转义字符**
有一类比较特殊的字符字面值，不能直接使用。在 ASCII 码中，除了字母、数字外还有很多符号，其中有一些本身在 C++ 语法中被用于特殊的用途，比如单引号、双引号、一些控制字符等，如果想要使用它们，就需要进行转义，这就是转义字符。

C++ 中规定的转义字符有：

| 符号名称   | 符号 | 符号名称   | 符号 | 符号名称       | 符号 |
| ---------- | ---- | ---------- | ---- | -------------- | ---- |
| 换行符     | \n   | 横向制表符 | \t   | 报警（响铃）符 | \a   |
| 纵向制表符 | \v   | 退格符     | \b   | 双引号         | \\"  |
| 反斜线     | \    | 问号       | \\?  | 单引号         | \\'  |
| 回车符     | \r   | 进纸符     | \f   |

注意：在 C++ 中，\n 是换行符（Line Feed），它只将光标移动到下一行的开头；而 \r 是回车符（Carriage Return），它将光标移动到当前行的行首。 它们在不同操作系统中有不同的行为：Windows 系统通常使用 \r\n（回车+换行）组合来表示换行，而Unix/Linux 系统和macOS 则分别使用 \n（换行）和 \r（回车）。 

#### 字符串字面值常量
多个字符组合在一起，就构成了字符串，字符串字面值就是一串字符，用双引号引起了表示。

字符串是字符的组合，所以字符串字面值本质上是 char 类型构成的数组（array）

示例："ABCDE"，"C++"

#### 布尔字面值
布尔字面值非常简单，只有两个：true 和 false.


### 类型转换

### 变量赋值自动类型转换
变量是有数据类型的，字面值常量也是有数据类型的，当使用字面值常量给变量赋值时可能会有一个问题，如果常量的值超出了变量类型能表示的范围，或者把一个浮点数赋值给整型变量，这时程序会进行自动类型转换。即，程序会自动将一个常量值转换成变量的数据类型，然后赋值给变量。

```c++
// 1. 整数值赋值给布尔类型。非零值赋值给布尔变量自动转换为 true，其他转为 false
bool b = 25;  // b 的值将为 true，打印结果为 1

// 2. 布尔值赋值给整型变量
short s = false; // s 的值为 0

// 3. 浮点数赋值给整型变量。只保留整数部分
int i = 3.14; // i 的值为 3

// 4. 整数赋值给浮点类型变量
float f = 10; // f 的值为 10.0，打印结果为 10

// 5. 赋值超出整型范围。会丢失超出范围的高位，只保留范围内的低位
unsigned short u = 65536 // u 的值是 0

// 6. 获取变量数据类型
int a = 0b1010;

std::cout << "Type of a: " << typeid(a).name() << std::endl;
```

转换规则：

- 非布尔类型的算术值赋值给布尔类型，如果算术值为 0，那么结果为 false，否则结果为 true;
- 布尔值赋值给非布尔类型，如果值为 false，那么结果为 0，如果值为 true，那么结果为 1；
- 浮点数赋值给整数类型，只保留浮点数中的整数部分，会带来精度丢失；
- 整数值赋给浮点类型，小数部分记为 0，如果保存整数需要的空间超过了浮点类型的容量，可能会有精度丢失；
- 给无符号类型赋值，如果超出它表示的范围，结果是初始值对无符号类型能表示的数值总数取模后的余数；
- 给有符号类型赋值，如果超出它表示的范围，结果是未定义的（undefined）。此时，程序可能继续工作，也可能崩溃。

#### 隐式类型转换
在 C++ 中，不同类型的数据对象，是可以放在一起做计算的，这就要求必须有一个机制，能让有关联的两种类型可以互相转换。上一节介绍了变量赋值时的自动类型转换，接下来我们对类型转换做更详细的展开。

大多数情况，C++ 编译器可以自动对类型进行转换，不需要我们干涉，这种方式叫做“隐式类型转换”。

隐式类型转换主要发生在算术类型之间，基本思路就是将长度较小的类型转换成较大的类型，这样可以避免丢失精度。隐式类型转换不仅可以在变量赋值时发生，也可以在运算表达式中出现。例如：

```c++
// 右侧是两个字面值常量相加，而且类型不同：15.2 是 double 类型；20 是 int 类型。
// 当它们相加时，会将 int 类型的 20 转换为 double 类型，然后执行 double 的加法
// 由于 s 变量是 short 类型，所以会把 double 类型的结果 35.2 先去掉小数部分，
// 再转换成 short 类型的 35
short s  = 15.2 + 20;

std::cout << s << std::endl; // s = 35
std::cout << "15.2 + 20 结果的长度为 " << sizeof(15.2 + 20) << std::enl; // 8, double 的长度

std::cout << "s 的长度为" << sizeof s << std::endl; // 2, short 的长度
```

隐式类型转换的一般规则：
- 在大多数算术运算中，较小的类型（如 bool, char, short）都会转换成 int 类型，叫做整数提升。而对于 wchar_t 等较大的扩展字符类型，则根据需要转换成 int, unsigned int, long, unsigned long, long long, unsigned long long 中能容纳它的最小类型;
- 当表达式中有整型也有浮点型时，整数值会转换成相应的浮点类型；
- 在条件判断语句中，其他整数类型会转换成布尔类型，即 0 为 false，非 0 为 true;
- 初始化变量时，初始值转换成变量的类型；
- 在赋值语句中，右侧对象的值会转换成左侧对象的类型。

此外，要尽量避免将较大类型的值赋给较小类型的变量，这样很容易出现精度丢失或者数据溢出。

```c++
int s = 32767;
std::cout << s + 1 << std::endl;

short s2 = s + 1;
std::cout << s2 <<std::endl;
```

还要注意如果希望判断一个整型变量 a 是否在某个范围，比如 (0, 100) 内，不能直接写成 `0 < a < 100;`，应该写成 `0 < a && a < 100;`

#### 强制类型转换
除去自动进行的隐式类型转换，也可以显式地要求编译器对数据对象的类型进行更改。这种转换叫做强制类型转换（cast）。

比如对于除法运算，整数除法和浮点数除法是不同的，如果希望对一组整数求一个平均值，直接相加后除以个数是无法得到想要的结果的。

因为两个 int 类型的数相除，执行的是整数除法，得到的是整数（整除），再转换成 double 类型得到的事整数隐式转换为浮点数，即增加上小数点而已。如果想要更准确的结果，就必须将除数从 int 类型强制转换成 double，做浮点数除法。

C++ 中可以使用不同的方式进行强制类型转换。

1. C语言风格
最经典的强制类型转换方式来自C语言，格式如下：
```c
(类型名称)值
```
把要强制转成的类型，用一个小括号括起来，放到要转换的对象值前面就可以。

2. C++函数调用风格
这种方式跟C语言的强转类似，只不过看起来更像是调用了一个函数：
```c++
类型名称(值)
```
要转成的类型名就像是一个函数，调用的时候，后面小括号里是传递给它的参数。

3. C++强制类型转换运算符
C++还引入了4个强制类型转换运算符`static_cast, dynamic_cast, reinterpret_cast, const_cast`，这种新的转换方式比前两种传统方式要求更为严格。通常在类型转换中用到的运算符是 `static_cast`，用法如下：
```c++
static_cast<类型名称>(值)
```
`static_cast` 运算符后要跟一个尖括号，里面是要转换成的类型。

强制类型转换会干扰正常的类型检查，带来很多风险，所以通常要尽量避免使用强制类型转换。


# 运算符

## 表达式和运算符
一个或多个运算对象的组合叫做表达式（expression），可以把它看成用来做计算的式子。对一个表达式进行计算，可以得到一个结果，有时也把它叫做表达式的值。

字面值常量和变量就是最简单的表达式，表达式的记过就是字面值和变量的值。多个字面值和变量可以通过一些符号链接组合在一起，表示进行相应的计算，得到更加复杂的表达式，这些符号就被叫做运算符（operator）.

C++ 中定义的运算符，包含一元运算符、二元运算符和三元运算符，分别作用于1、2、3个字面值常量或变量。

运算符具有优先级，和数学运算保持一致。运算符具有结合律，但可以通过小括号改变运算优先级和结合律。

## 算术运算
算术运算符表示算术计算的加减乘除等，如下表所示

| 运算符 | 功能     | 用法        |
| ------ | -------- | ----------- |
| +      | 一元正号 | + expr      |
| -      | 一元负号 | - expr      |
| *      | 乘法     | expr * expr |
| /      | 除法     | expr / expr |
| %      | 求余     | expr % expr |
| +      | 加法     | expr + expr |
| -      | 减法     | expr - expr |

需要注意的是，同一个运算符，在不同的场合可能表达不同的含义。比如 "-"，可以是减号，也可以是负号，如果直接放在一个表达式前面，就表示对表达式的结果取负数，这是一元运算符，如果连接两个表达式，就是两者结果相减，是二元运算符。

算术运算符的优先级：一元运算符（正负号）最高，其次是乘、除和取余（或叫求模），最后是加减。

算术运算符可以用于基本数据类型（除了 void 空类型），包括整型、char 类型、bool 类型、浮点类型等。但是，求余或取模预算符只能针对整型。

```c++
// 类型提升
short a = 3;
long long b = 23435;
long long c = a * b; // right

// 除法结果包含小数，而不是整除。这种功能叫做运算符重载
float a1 = 20;
short b1 = 3;
float c1 = a1 / b1; // right
```

算术运算符规则：
- 算术运算符满足左结合律，也就是说相同优先级的运算符，将从左到右按顺序进行组合；
- 算术运算符可以用来处理任意算术类型的数据对象；
- 不同类型的数据对象进行计算时，较小的整数类型会被“提升”为较大的类型，最终转换成同一类型进行计算；
- 对于除法运算“/”，执行计算的结果跟操作数的类型有关。如果它的两个操作数（也就是被除数和除数）都是整数，那么得到的结果也只能是整数，小数部分会被直接舍弃，这叫整数除法。当至少有一个操作数是浮点数时，结果就会是浮点数，保留小数部分；
- 对于取余运算，两个操作数必须是整数类型；

## 赋值
将一个表达式的结果，传递给某个数据对象保存起来，这个过程叫做赋值。

在 C++ 中，用等号“=”表示一个赋值操作，这里的“=”就是赋值运算法。需要注意的是，赋值运算符的左边，必须是一个可修改的数据对象。

赋值运行规则：
- 赋值运算或表达式的结果，就是它左侧的运算对象，结果的类型就是左侧运算对象的类型；
- 如果赋值运算符两侧对象类型不同，就把右侧的对象转换成左侧对象的类型；
- C++ 11新标准提供了一种新的语法：用花括号{}括起来的数值列表，可以作为赋值右侧对象。这样就可以非常方便地对一个数组赋值了；
- 赋值运算符满足结合律。也就是说，可以在一条语句中连续赋值，结合顺序是从右到左；
- 赋值运算符优先级较低，一般都会先执行其他运算符，最后做赋值。


```c++
int d = {3};
int arr[] = {1, 2, 3, 4, 5};
int a = b = 20; // 连续赋值。因为 b = 5 表达式先将 5 赋值给 b，然后返回表达式的值 5，赋值给变量 a
```

### 复合赋值运算符
实际使用中，可能需要把一次计算的结果再赋值给参与运算的某一个变量：

```c++
int sum = 3;
sum = sum + 4;
sum = sum + 5;
```

注意，赋值运算符“=”不是数学上“=”的意思，`sum = sum + 4`表示把 `sum + 4`的结果赋值给`sum`变量。

为了更加简洁，C++ 提供了一类特殊的赋值运算符，可以把要执行的算术运算“+”跟赋值“=”结合在一起，用一个运算符“+=”来表示，这就是复合赋值运算符。

复合赋值运算一般结合的是算术运算符或者位运算符：

```c++
+=, -=, *=, /=, %=  // 算术运算符
<<=, >>=, &=, ^=, |= // 位运算符
```

### 递增递减运算符或自增自减运算符
C++ 为数据对象的“加一”“减一”操作，提供了更加简洁的表达方式，这就是递增和递减运算符（也叫作自增和自减运算符）。递增用两个加号“++”表示对象值加一，再赋值给原对象，递减用两个减号“--”表示对象值减一，再赋值给原对象。

```c++
++a; // a 递增，相当于 a += 1
--a; // a 递减，相当于 a -= 1
```

递增递减运算符各自有两种形式：前置和后置，也就是说写成`++a`, `--a`都可以。都表示 `a = a + 1`，区别在于表达式返回的结果不同：
- 前置时，对象先加1，再将更新后的对象值作为结果返回；
- 后置时，对象先将原始值作为结果返回，再加1；

注意，如果我们单独使用递增递减运算符，前置和后置效果一样，但是如果表达式的运算结果还要进一步做运算，两者就有明显不同了。

```c++
int i = 0, j;
j = ++i; // i = 1, j = 1

int i = 0, j;
j = i++; // i = 1, j = 0
```

## 关系运算符

| 运算符 | 功能     | 用法         |
| ------ | -------- | ------------ |
| <      | 小于     | expr < expr  |
| <=     | 小于等于 | expr <= expr |
| >      | 大于     | expr > expr  |
| >=     | 大于等于 | expr >= expr |
| ==     | 相等     | expr == expr |
| !=     | 不相等   | expr != expr |

```c++
1 < 2; // true
3 >= 5; // false

10 == 4 + 6 // true
(10 != 4) + 6; // 1 + 6, 7
```

算术运算符的优先级高于关系运算符，如果加上小括号可以调整计算顺序。

## 逻辑运算符
关系运算符的结果是一个布尔类型（true or false），表示一个条件，如果要多个条件叠加，需要用逻辑运算（与、或、非）将这些布尔类型组合起来，这样的运算符叫做逻辑运算符。

- 逻辑与 `&&`，二元运算符，当两个对象都为 true 时结果才为 true，否则结果为 false
- 逻辑或 `||`，二元运算符，当两个对象都为 false 时结果才为 false，否则结果为 true
- 逻辑非 `!`，一元运算符，当对象为 true 时结果为 false，当对象为 false 时结果为 true.

```c++
1 < 2 && 3 >= 5; // false
1 < 2 || 3 >= 5; // true
1(1 < 2 || 3 >= 5); // false
```

逻辑运算符和关系运算符的用法、优先级总结如下：

| 运算符 | 功能     | 用法           |
| ------ | -------- | -------------- |
| ！     | 逻辑非   | !expr          |
| ——     | ——       | ——             |
| <      | 小于     | expr < expr    |
| <=     | 小于等于 | expr <= expr   |
| >      | 大于     | expr > expr    |
| >=     | 大于等于 | expr >= expr   |
| ——     | ——       | ——             |
| ==     | 相等     | expr == expr   |
| !=     | 不相等   | expr != expr   |
| ——     | ——       | ——             |
| &&     | 逻辑与   | expr && expr   |
| ——     | ——       | ——             |
| \|\|   | 逻辑或   | expr \|\| expr |

注意：
- 如果将一个算术类型的对象作为逻辑运算符的操作数，那么值为 0 表示 false，非 0 值表示 true;
- 逻辑与、逻辑或都有两个运算对象，在计算时都是先求左侧对象的值，再求右侧对象的值；如果左侧对象的值已经能够决定表达式的最终结果（如逻辑与中左侧对象的值为 false， 逻辑或中左侧对象的值为 true 时），那么右侧就不会执行计算。这就是“短路求值”。

```c++
i = -1;
1 < 2 && ++i;  // false，先左侧再右侧，计算 ++i 表达式

1 < 2 || ++i;  // true，先左侧，不再执行右侧，短路求值
```

## 条件运算符
C++ 还从 C 语言继承了一个特殊的运算符，叫做“条件运算符”。它由“?”和“:”两个符号组成，需要三个运算表达式，形式如下：
```bash
条件判断表达式 ? 表达式1 : 表达式2
```

它的含义是计算条件判断表达式的值，如果为 true 就执行表达式 1，返回求值结果；如果为 false 则跳过表达式 1，执行表达式 2，返回求值结果。这也是 C++ 中唯一的一个三元运算符。

```c++
int i = 0;
std::cout << ((1 < 2 && ++i) ? "true" : "false") << std::endl;
```

- 条件运算符的优先级比较低，所以输出的时候需要加上括号
- 条件运算符满足右结合律（多个条件运算符情况）

事实上，条件运算符等同于流程控制中的分支语句 `if ... else ...`，只用一条语句就可以实现按条件分支处理，这就让代码更加简洁。

## 位运算符
C++ 中位运算符可以直接操作数据具体的每一位。位运算符分为两大类：移位运算符和位逻辑运算符。

| 运算符 | 功能   | 用法           |
| ------ | ------ | -------------- |
| ~      | 位求反 | ~expr          |
| <<     | 左移   | expr1 << expr2 |
| >>     | 右移   | expr1 >> expr2 |
| &      | 位与   | expr & expr    |
| ^      | 位异或 | expr ^ expr    |
| \|     | 位或   | expr \| expr   |

### 移位运算符
算术类型的数据对象，都可以看作是一组“位”的集合。利用“移位运算符”可以让运算对象的所有位整体移动指定的位数。

移位运算符有两种，左移运算符“<<” 和右移运算符“>>”。在在前面输入输出操作时用过该符号，作为标准IO库里定义的运算符重载。

```c++
unsigned char bits = 0xb5;  // 10110101 一个字节

bits << 2 // 先提升成 int 类型，然后左移两位，右侧补 0
bits << 31 // 左移31位，右侧补0，左侧超出4字节的部分被丢弃


```

- 较小的整数类型（char, short 以及 bool）会自动提升成 int 类型再做移位，得到的结果也是 int 类型
- 左移运算符将操作数左移以后，在右侧补0
- 右移运算符将操作数右移之后，对于无符号数交在左侧补0；对于有符号数的操作则要看运行的机器环境，有可能补符号位，也有可能直接补0；
- 由于有符号数右移结果不确定，一般只对无符号数执行位移操作。

```c++
unsigned char bites = 0xb5; 

std::cout << hex; // 以十六进制显示；默认是十进制
std::cout << "0xb5 左移 2 位：" << (bits << 2) << std::endl;

std::cout << dec; // 再转换为以十进制显示
std::cout << "0xb5 右移 2 位：" << (bits >> 2) << std::endl;

// 左移超过 31 位，对 32 取余后的位数为准，如下面的左移34，和左移2位是等价的
std::cout << "0xb5 左移 34 位：" << (bits << 34) << std::endl;
```

### 位逻辑运算符
计算机存储的每一个位（比特 bit）都是二进制的，有 0 和 1 两种取值，这跟布尔类型的真值表达非常类似。于是自然可以想到，两个位上的 0 或 1 都可以执行类似逻辑运算的操作。

位逻辑运算符有：按位取反 `~`，位与 `&`，位或 `|` 和位异或 `^`。
- 按位取反 `~`：一元运算符，类似逻辑非，对每个位取反值，也就是把 1 置为 0， 0 置为 1；
- 位与 `&`：二元运算符，类似逻辑与，两个数对应位上都为 1，结果对应位为 1；否则结果对应位为 0；
- 位或 `|`：二元运算符，类似逻辑或，两个数对应位上只要有 1，结果对应位就为 1；如果全为 0 则结果对应位为 0；
- 位异或 `^`：两个数对应位相同，则结果对应位为 0，不同则结果对应位为 0.

```c++
// 找单数
int i1 = 5; i2 = 9; i3 = 12; i4 = 9; i5 = 5;
std::cout << (i1 ^ i2 ^ i3 ^ i4 ^ i5) << std::endl;
```

# 流程控制语句
C++程序执行的流程结构可以有三种：顺序、分支和循环。除了最简单的顺序结构是默认的，分支和循环都需要使用专门的“流程控制语句”来定义。

## 语句
C++中表示一步操作的一句代码，就叫做语句（statement），大多数语句都是以英文分号“;”结尾的。C++程序运行的过程其实就是找到主函数，然后从上到下顺序执行每条语句的过程。

### 简单语句
使用各种运算符，作用到数据对象上，就得到了“表达式”，一个表达式末尾加上分号，就构成了“表达式语句”（expression statement）。

表达式语句表示，要执行表达式的计算过程，并且丢弃最终返回的结果。

```c++
int a = 0; // 变量定义并初始化语句
a + 1; // 算术表达式语句，无意义
++a; // 递增语句，a 的值变为 1
std::cout << a << std::endl; // 输出语句
```
其中，第二行 `a + 1;` 是没有意义的，因为它只是执行了加法操作，却没有把结果保存下来（赋值给别的变量），`a` 的值也没有改变，也没有任何附带效果（比如最后一句的输出）。

最简单的语句，其实是“空语句”，就是只有一个分号的语句：
```c++
;  // 空语句
```

这看起来好像没有什么用，不过有时候，可能程序在语法上需要有一条语句，而逻辑上什么都不用做，这时就应该用一条空语句来填充。

初学C++一定不要忘记语句末尾的英文分号，当然，对于不需要分号的场景，也尽量避免多写分号。

### 复合语句
简单语句从上到下按顺序依次执行，这非常符合我们对计算机运行的预期。但是很多场景，简单的顺序结构远远不能满足逻辑需要，比如，我们可能需要按照条件判断，做程序的分支执行；也可能需要将一段代码循环执行多次，这就需要一些“流程控制语句”（如，`if, while, for`等）来表达更加复杂的操作。

而对于流程控制语句，逻辑上来说只是一条语句，事实上却可能包含了多条语句、复杂的操作。这就需要用一个花括号`{}`，把这一组语句序列包成一个整体，叫做“复合语句”（compound statement），也叫做“块”（block）。

```c++
int i = 0;
while (i < 5) {
    int a = i;
    ++i;
    std::cout << a << std::endl;
}
```

这里的 `while` 表示一个循环，后面只能跟要循环执行的一条语句，如果我们想写两条语句，就要用花括号括起来，构成“块”。

对于复合语句（块）需要注意：
- 花括号后面不需要再加分号，块本身就是一条语句；
- 块内可以声明变量，变量的作用域仅限于块内部；
- 只有一对花括号、内部没有任何语句的块叫做“空块”，等价于空语句。

## 条件分支
很多情况下，我们为程序的执行会提供“岔路”的选择机会。一般都是满足某种条件就执行A操作，满足另一种条件就执行B操作。这样的程序结构叫做“条件分支”。

C++提供了两种按条件分支执行的控制语句：`if` 和 `switch`.

### if
`if` 语句主要就是判断一个条件是否为真（true），如果为真就执行下面的语句，如果为假则跳过。具体形式可以分为两种：一种是单独一个 `if`，一般称为”单分支“，另一种是 `if ... else ...`，称为“双分支”。

**单分支**

单分支是最简单的 `if` 用法，判断的条件用小括号括起来跟在 `if` 后面，然后是如果条件为真要执行的语句。基本形式为

```c++
if (条件判断) {
    语句
}
```

如果条件为假，那么这段代码就会被完全跳过。

```c++
// 输入用户年龄，判断后显示欢迎信息
std::cout << "请输入您的年龄：" << endl;
int age;  // 局部变量声明，使用前必须要赋值事先
cin >> age;

// 单分支
if (age >= 18) { // 如果花括号中只有一个语句，花括号可以省略
    std::cout << "欢迎您，已成年" << std::endl;
}
```

**双分支**

双分支就是在 `if` 分支的基础上，加上 `else` 分支；条件为真就执行 `if` 后面的语句，条件为假就执行 `else` 后面的语句，基本形式如下：

```c++
if (条件判断) {
    语句1
} else {
    语句2
}
```

```c++
// 输入用户年龄，判断后显示欢迎信息
std::cout << "请输入您的年龄：" << endl;
int age;  // 局部变量声明，使用前必须要赋值事先
cin >> age;

// 单分支
if (age >= 18) { // 如果花括号中只有一个语句，花括号可以省略
    std::cout << "欢迎您，已成年" << std::endl;
} else {
    std::cout << "您未成年" << std::endl;
}

// 三元表达式
age >= 18 ? (std::cout << "欢迎您，已成年" << std::endl) : (std::cout << "您未成年" << std::endl);

std::cout << (age >= 18 ? "欢迎您，已成年" : "您未成年") << std::endl;
```

**嵌套分支**

程序中的分支有可能不只两个，这时就需要对 `if` 分支或者 `else` 分支再做条件判断和拆分了，这就是“嵌套分支”。

简单来说，就是 `if` 或者 `else` 分支的语句块里，继续使用 `if` 或者 `if ... else ...` 按条件进行分支。这是一种“分层”的条件判断。

嵌套分支如果比较多，代码的可读性会大幅降低。所以还有一种更加简单的嵌套分支写法，那就是 `if ... else if ...`，具体形式如下：

```c++
if (条件判断1) {
    语句1
} else if (条件判断2) {
    语句2
} else if (条件判断3) {
    语句3
} else {
    语句n
}
```

### while
在一些应用场景中，要判断的条件可能不是范围，而是固定的几个值。比如考试成绩只分"A, B, C, D" 四个档位，分别代表“优秀，良好，及格，不及格”。

这时候如果用 `if ... else ...` 会显得非常繁琐，而 `switch` 语句就是专门为了这种分支场景设计的。

`switch` 语法基本形式如下：

```c++
switch (表达式) {
    case 值1:
        语句1
        break;
    case 值2:
        语句2
        break;
    ...
    default:
        语句n
        break;
}
```

这里 `switch` 后面的括号里是一个表达式，对它求值，然后转换成整数类型跟下面每个 `case` 后面的值做比较；如果相等，就进入这个 `case` 指定的分支，执行后面的语句，直到 `switch` 语句结束或者遇到 `break` 退出。需要注意的是：

- `case` 关键字和后面对应的值，合起来叫做一个 `case` 标签， `case` 标签**必须是一个整型的常量表达式**；
- 任何两个 `case` 标签不能相同；
- `break` 语句的作用是“中断”，会直接跳转到 `switch` 语句结构的外面；
- 如果没有 `break` 语句，那么匹配某个 `case` 标签之后，程序会从上到下一直执行下去，这会执行多个标签下面的语句，可能发生错误；
- 如果没有匹配上任何 `case` 标签的值，程序会执行 `default` 标签后面的语句；`default` 是可选的，表示“默认要执行的操作”。

## 循环
可以重复执行一组操作的语句叫做“循环”，有时也叫作“迭代”，循环一般不能无限进行下去，所以会设置一个终止的判断条件。

C++中的循环语句，有 `while, do while, for` 三种。

### while
`while` 只需要给定一个判断条件，只要条件为真，就重复地执行语句。形式如下：

```c++
while (condition) {
    statement
}
```

要执行的语句往往会有多条，这就需要用花括号将它们括起来。这个块一般被称为“循环体”。

一般来说，用来控制 `while`循环的条件中一定会包含变量，通常叫做“循环变量”，而它或者在条件中变化，或者在循环体中变化，这样才能保证循环能够终止退出。

### do while
`do while` 和 `while` 非常类似，区别在于 `do while` 是先执行循环体中的语句，然后再检查条件是否满足。所以 `do while` 至少会执行一次循环体。

`do while` 语法形式如下：

```c++
do {
    statements
} while (condition);
```

### for
通过 `while` 和 `do while` 可以总结出来，一个循环主要有这样几个要素：

- 一个条件，用来控制循环退出；
- 一个循环体，用来定义循环要执行的操作。

而一般情况下，我们都是通过一个循环变量来控制条件的，这个变量需要随着循环迭代次数的增加而变化。`while` 和 `do while` 的循环变量，都是在循环体外单独定义的。

`for` 是用法更加明确的循环语句。它可以把循环变量的定义、循环条件以及循环变量的改变都放在一起，统一声明出来。

**经典`for`循环**

`for` 循环的经典语法形式是：

```c++
for (初始化语句; 条件; 表达式) {
    语句
}
```

关键字 `for` 和它后面括号里的部分，叫做 `for` 语句头。

`for` 语句头中有三部分，用分号分隔，主要作用是：

- 初始化语句负责初始化一个变量，这个变量值会随着循环迭代而改变，一般就是“循环变量”；
- 中间的条件是控制循环执行的关键，为真则执行下面的循环体语句，为假则退出。条件一般会以循环变量作为判断标准；
- 最后的表达式在本次循环完成之后再执行，一般会对循环变量进行更改。

这三个部分并不是必要的，根据需要都可以省略。如果省略某个部分，需要保留分号表示这是一个空语句。

**范围`for`循环**

C++11 新标准引入了一种更加简单的 `for` 循环，这种语句可以直接遍历一个序列的所有元素。这种 `for` 循环叫做“范围`for`循环”。语法形式如下：

```c++
for (声明: 序列表达式) {
    语句
}
```

这里 `for` 语句头中的内容就很简单了，只需要声明一个变量，后面跟上一个冒号（注意不是分号），再跟上一个序列的表达式就可以了。所谓“序列”，其实就是一组相同类型的数据对象排成了一列来统一处理；所以这个声明的意思，其实就是从序列中依次取出所有元素，每次都赋值给这个变量。

所以范围 `for` 循环的特点就是，不需要循环变量，直接就可以访问序列中的所有元素。

```c++
// 范围for循环
for (int num: {3, 6, 9}) {
    std::cout << "序列中数据有：" << num << std::endl;
}
```

### 循环嵌套
循环语句和分支语句一样，也是可以进行嵌套的。具体可以 `while` 循环中嵌套 `while`，可以 `for` 循环中嵌套 `for`，也可以 `while, do while, for` 混合嵌套。因为 `for` 的循环变量定义更明确，所以一般用 `for` 的循环嵌套会多一些。

```c++
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 5; j++) {
        std::cout << i, j << std::endl;
    }
}
```

循环嵌套之后，内层语句执行的次数，将是外层循环次数和内层循环次数的乘积。这会带来大量的时间消耗，使程序运行变慢，所以使用循环嵌套要非常谨慎。

## 跳转
在流程控制语句中还有一类“跳转语句”，主要用来中断当前的执行过程。C++中有四种跳转语句：`break, continue, goto, return`。

### break
`break` 语句表示要“调出”当前的流程控制语句，它只能出现在 `switch` 或者循环语句（`while, do while, for`）中，当代码中遇到 `break` 时，会直接中断距离最近的 `switch` 或者循环，跳转到外部继续执行。

```c++
// 输出1到10
int i = 1;
while (true) {
    std::cout << i << std::endl;
    i++;
    if (i > 10) {
        break;
    }
}
```

### continue
`continue` 语句表示“继续”执行循环，也就是中断循环中的本次迭代、并开始进行下一次迭代。很明显，`continue` 只能用在循环语句中，同样针对最近的一层循环有效。

`continue` 非常适合处理需要“跳过”某些情况的场合。

```c++
for (int num = 1; num < 100; num++) {
    // 如果是7的倍数，或者数字钟有7，则跳过
    if (num % 7 == 0 || num % 10 == 7 || num / 10 == 7) {
        continue;
    }
    std::cout << num << std::endl;
}
```

### goto
`goto` 语句表示无条件地跳转到程序中的另一条语句。`goto` 的语法形式为：

```c++
goto 标签
```

这里的“标签”可以认为是一条语句的“名字”，跟变量类似，只不过它是指代一条语句的标识符。定义标签也非常简单，只要在一条语句前写出标识符，然后跟上冒号就可以了。比如：

```c++
beginTag: int a = 0;
```

下面是一个具体的例子：

```c++
int x = 0;
begin:
    do {
        std::cout << "x = " << x << std::endl; 
        x++;
    } while (x < 10);

if (x < 15) { // 强制续命5年
    std::cout << "回到原点" << std:endl;
    goto begin;
}

std::cout << "程序结束" << std:endl;
```

# 复合数据类型
C++中不仅有基本数据类型，还提供了更加灵活和丰富的复合数据类型。

## 数组
在程序中为了处理方便，常常需要把具有相同类型的数据对象按有序的形式排列起来，形成“一组”数据，这就是“数组”（array）.

数组中的数据，在内存中是连续存放的，每个元素占据相同大小的空间，就像排好队一样。

### 数组定义
数组的定义形式如下：

```c++
数组类型 数组名[元素个数];
```

- 首先需要声明类型，数组中所有元素必须具有相同的数据类型；
- 数组名是一个标识符，后面跟着中括号，里面定义了数组中元素的个数，也就是数组的“长度”；

### 数组初始化
之前讲 `for` 循环时，提到过使用范围 `for` 循环可以遍历一个“序列”，用花括号括起来的一组数就是一个序列。所以在给数组赋值时，也可以使用这样的序列。

```c++
int a1[4] = {1, 2, 3, 4};

float a2[] = {1.2, 2.3, 3.4}; // 正确，初始值说明了元素个数是3

short a3[5] = {1, 3}; // 正确，指定了前三个元素，其余都为0

long a4[2] = {1, 2, 3}; // 错误，初始值太多

int a5[4] = a1; // 错误，不能用另一个数组对数组赋值

const int n = 4;
int a6[n]; // 正确，n是常量不能改变，如果是变量则会报错
```

需要注意的是：

- 对数组做初始化，要使用花括号`{}`括起来数值序列；
- 如果做了初始化，数组定义时的元素个数可以省略，编译器可以根据初始化列表自动推断出来；
- 初始值的个数，不能超过指定的元素个数；
- 初始值的个数，如果小于元素个数，那么会用列表中的值初始化靠前的元素；剩余元素用默认值填充；
- 如果没有做初始化，数组中元素的值都是未定义的（也会填充，值为`0xcc`）。

### 数组的访问
**访问数组元素**

数组元素在内存中是连续存放的，它们排好了对之后就会有一个队伍中的编号，称为索引，也叫下标，通过下标就可以快速访问每个元素了，具体形式为

```c++
数组名[元素下标]
```

这里也是用了中括号来表示元素下标位置，被称为下标运算符。比如 `a[2]` 就表示数组 `a` 中下标为 `2` 的元素，可以取它的值输出，也可以对它赋值。

```c++
int a[] = {1, 2, 3};
std::cout << a[2] << std::endl; // 3

a[2] = 33;  // 这里需要注意，如果下标超过数组个数，那么修改可能会把内存中未知的的区域修改造成系统风险
std::cout << a[2] << std::endl; // 33
```

需要注意：

- 数组的下标从 0 开始；
- 因此 `a[2]` 访问的事数组的第 3 个元素，一个长度为 `n` 的数组，下标范围是 `0 ~ n-1`；
- 合理的下标，不能小于 0， 也不能大于 （数组长度 - 1），否则就会出现数组下标越界。

**数组大小**

所有的变量，都会在内存中占据一定大小的空间，而数据类型就决定了它具体的大小。而对于数组这样的复合类型，由于每个元素类型相同，因此占据空间大小的计算遵循下面的简单公式：

```c++
数组所占内存空间  = 数据类型所占空间大小 * 数组中元素个数
```

这样一来，即使定义的时候没有指定数组元素的个数，现在也可以计算个数为

```c++
// 假设 a 是已经定义的数组

std::cout << "数组 a 占用空间大小：" << sizeof(a) << std::endl;
std::cout << "数组 a 中每个元素占用空间大小：" << sizeof(a[0]) << std::endl;

// 获取数组长度
int aSize = sizeof(a) / sizeof(a[0])
std::cout << "数组 a 元素个数：" << aSize << std::endl;

// 遍历数组
for (int num: a) {
    std::cout << num << std::endl;
}
```

### 多维数组
之前介绍的数组只是数据最简单的排列方式，如果数据对象排列成的不是一队，而是一个矩阵，那显然就不能只用一个下标来表示了。我们可以对数组进行扩展，让它从一维编程二维，甚至多维。

```c++
int arr[3][4]; // 二维数组。有三个元素，每一个元素都是一个长度为 4 的 int 数组

int array[2][5][10]; // 三维数组
```

C++中本质上没有多维数组这种东西，所谓的多维数组，就是数组的数组。

- 二维数组 `int arr[3][4]`: arr 是一个有三个元素的数组，其中每个元素都是一个 int 数组，包含 4 个元素；
- 三维数组 `int array[2][5][10]`： 表示长度为 2 的数组，其中每个元素都是一个二维数组，每个二维数组有 5 个元素，每个元素都是一个长度为 10 的 int 数组。

一般最常见的就是二维数组，它有两个维度，第一个维度表示数组本身的长度，第二个表示每个元素的长度。一般分别把它们叫做行和列。

（1）多维数组的初始化

和普通的一维数组一样，多维数组初始化时，也可以用花括号括起来的一组数。使用嵌套的花括号可以让不同的维度更清晰：

```c++
数据类型 数组名[行数][列数] = {数据1, 数据2, ...};

数据类型 数组名[行数][列数] = {
    {数据11, 数据12, ...},
    {数据21, 数据22, ...},
    ...
};
```

需要注意：

- 内嵌的花括号不是必需的，因为数组中的元素在内存中连续存放，可以用一个花括号将所有数据扩在一起；
- 初始值的个数可以小于数组定义的长度，其它元素初始化为 0 值；这一点对整个二维数组和每一行的一维数组都使用；
- 如果省略嵌套的花括号，当初始值个数小于总元素个数时，会按照顺序依次填充（填满第一行，才填第二行）；其它元素初始化为 0 值；
- 多维数组的维度，可以省略第一个，由编译器自动推断；即二维数组可以省略行数，但不能省略列数。

```c++
int ndarr[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 1, 2}
};

int ndarr1[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2};

int ndarr2[3][4] = {12};

int ndarr3[][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2}; // 知道列，可以推断行

std::cout << ndarr[1][2] << std::endl;

ndarr[2][3] = 119;

std::cout << ndarr[2][3] << std::endl;

// 遍历
for (auto& row: ndarr) { // 自动推断类型
    for (auto num: row) {
        std::cout << num << "\t";
    }
    std::cout << std::endl;
}
```

### 选择排序
工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后追加到已经排序序列的末尾，以此类推，知道所有元素均排序完毕。

```c++
#include <iostream>

int main() {
    int arr[] = {5, 9, 2, 3, 7, 9, 2, 10, 1};

    int size = sizeof(arr) / sizeof(arr[0]);

    // 选择排序
    for (int i = 0; i < size; i++) {
        for (int j = i + 1; j < size; j++) {
            if (arr[j] < arr[i]) {
                // 如果 arr[j] 更小，就和 arr[i] 交换位置
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
    }

    for (int num: arr) {
        std::cout << num << std::endl;
    }
}
```

### 冒泡排序
基本原理：重复地扫描要排序的数列，一次比较两个元素，如果它们的大小顺序错误，就把它们交换过来。这样，一次扫描结束，我们可以确保最大（小）的值被移动到序列末尾。这个算法的名字由来，就是因为越小的元素会经由交换，满满浮到数列的顶端。

```c++
for (int i = 0; i < size; i++) {
    for (int j = 0; j < size - i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
            int temp = arr[j + 1];
            arr[j + 1] = arr[j];
            arr[j] = temp;
        }
    }
}
```

## 模板类 vector
数组尽管很灵活，但使用起来还是有很多不方便，如数组一旦定义，长度不能改变等。为此，C++语言定义了扩展的抽象数据类型（Abstract Data Type, ADT），放在“标准库”中。

对数组功能进行扩展的一个标准库类型就是容器 vector，顾名思义，vector 容纳着一堆数据对象，其实就是一组类型相同的数据对象的集合。

### 头文件和命名空间
vector 是标准库的一部分，要想使用 vector，必须在程序中包含 `<vector>` 头文件，并使用 `std` 命名空间。

```c++
#include <vector>

using namespace std;
```

在 `vector` 头文件中，对 `vector` 这种类型做了定义，使用 `#include` 引入它之后，并指定命名空间 `std` 之后，我们就可以在代码中直接使用 `vector` 了。

### vector 的基本用法
vector 其实是 C++ 中的一个类模版，是用来创建类的模子，所以在使用时还必须提供具体的类型信息，也就是说，这个容器中到底要容纳什么类型的数据对象。具体的形式是在 vector 后面跟一个尖括号 <>，里面填入具体类型信息。

```c++
vector<int> v;
```

**初始化**

跟数组对比，vector 的初始化更加灵活方便，可以应对各种不同的需求。

```c++
// 默认初始化
vector<int> v1;

// 列表初始化（也叫拷贝初始化）
vector<char> v2 = {'a', 'b', 'c'};
vector<char> v3{'a', 'b', 'c'};

// 直接初始化
vector<short> v4(5); // 初始化向量 v4 包含 5 个元素
vector<long> v5(5, 100); // 初始化向量 v5，包含 5 个元素，都是 100

// 访问元素
std::cout << v5[3] << std::endl;
v5[3] = 25;

std::cout << v5[6] << std::endl; // 错误，运行会报错，不像数组可能会修改其他内存数据，影响系统安全

std::cout << "v5 的长度（元素个数）：" << v5.size() << std::endl;

for (int num: v5) {
    std::cout << num << "\t"
}

// 添加元素
v5.push_back(69);
```

### vector 和数组的区别
- 数组是更加底层的数据类型，长度固定，功能较少，安全性没有保证。但性能更好，运行更高效；
- vector 是模板类，是数组的上层抽象，长度不定，功能强大，缺点是运行效率较低。

除了 vector 之外，C++11还新增了一个 array 模板类，它跟数组更加类似，长度是固定的，但更加方便、更加安全。所以在实际应用中，一般推荐对于固定长度的数组使用 array，不固定长度的数组使用 vector.


## 字符串

字符串是一串字符连在一起组成的，比如用双引号引起来的 "hello world!" 就是一个字符串字面值。

字符串其实就是所谓的“纯文本”，就是各种文字、数字、符号在一起表达的一串信息。所以字符串就是 C++ 中用来表达和处理文本信息的数据类型。

### 标准库类型 string

C++ 的标准库中，提供一种用来表示字符串的数据类型 string，这种类型能够表示长度可变的字符序列。和 vector 类似，string 类型也定义在命名空间 std 中，使用它必须包含 string 头文件。

```c++
#include<string>

using namespace std;
```

**定义和初始化 string**

string 也是一个标准库类型，它的初始化与 vector 非常相似。

```c++
// 默认初始化，空字符串
string s;

// 拷贝初始化
string s2 = s;
string s3 = "hello, world";

// 直接初始化
string s4("hello, wolrd");
string s5(8, "x");
```

**初始化方式主要有**

1. 默认初始化，得到的就是一个空字符串；
2. 拷贝初始化，用赋值运算符表示，可以使用另一个 string 对象，也可以使用字符串字面值常量；
3. 直接初始化，用括号表示，可以在括号中传入一个字符串，也可以传入字符和重复的次数。

可以发现，字符串也可以看做数据元素的集合，它里面的元素就是字符。


**处理字符串中的字符**

通过初始化已经可以看出，string 的行为和 vector 非常类似。string 同样也可以通过下标运算访问内部的每个字符，字符的索引就是在字符串中的位子。

```c++
string str = "hello world";

std::cout << "str[2] = " << str[2] << std::endl;

// 将第一个字符改为 'H'
str[0] = 'H';

// 将最后一个字符改为 'D'
str[str.size() - 1] = 'D';

```

字符串内字符的访问跟 vector 内元素的访问类似，需要注意：
- string 内字符的索引，也是从 0 开始；
- string 同样有一个成员函数 size，可以获取字符串的长度；
- 索引最大值为 （字符串长度 - 1），不能越界访问；如果直接越界访问并赋值，有可能导致非常严重的后果，出现安全问题；
- 如果希望遍历字符串的元素，也可以使用普通 for 循环和范围 for 循环，依次获取每个字符。

```c++
string s = "hello, world!";

// 把字符串所有元素改为大写
for (int i = 0; i < s.size(); i++) {
    s[i] = toupper(s[i]);
}
```

**字符串相加**

string 本身的长度是不定的，可以通过“相加”的方式扩展一个字符串。

```c++
// 字符串相加
string str1 = "hello", str2("world");

string str3 = str1 + str2; // "helloworld"

string str4 = str1 + ", " + str2 + "!"; // "hello, world!"

// string str5 = "hello, " + "world!"; // 错误，不能将两个字符串字面值[char数组]相加
```

需要注意：
- 字符串相加室用加号“+”来表示，这是算术运算符“+”的运算符重载，含义是“字符串拼接”；
- 两个 string 对象，可以直接进行字符串相加，结果是将两个字符串拼接在一起，得到一个新的 string 对象返回；
- 一个 string 对象和一个字符串字面值常量可以进行字符串相加，同样得到一个拼接后的 string 对象返回；
- 两个字符串字面值常量不能相加；
- 多个 string 对象和多个字符串字面值常量，可以连续相加；前提是按照左结合律，每次相加必须保证至少有一个 string 对象。

**比较字符串**

string 类还提供几种用来做字符串比较的运算符，"==" 和 "!=" 用来判断两个字符串是否完全一样，而 "<", ">", "<=", ">=" 则用来比较两个字符串的大小。这些都是关系型运算符的重载。

```c++
str1 = "hello";
str2 = "hello world!";
str3 = "hehehe";

str1 == str2;  // false

str1 < str2;  // true

str1 >= str3;  // true
```

字符串比较的规则是：

- 如果两个字符串长度相同，每个位置包含的字符也都相同，那么两者“相等”，否则“不相等”；
- 如果两个字符串长度不同，而较短的字符串每个字符都跟较长字符串对应位置字符相同，那么较短字符串“小于”较长字符串；
- 如果两个字符串在某一位置上开始不同，那么就比较这两个字符的 ASCII 码，比较结果就代表两个字符串的大小关系。

### 字符数组（C风格字符串）
通过对 string 的介绍可以发现，字符串就是一串字符的集合，本质上其实就是一个“字符的数组”。

在 C 语言中，确实是用 `char[]` 类型来表示字符串的。不过为了区分纯粹的“字符数组”和“字符串”，C语言规定，字符串必须以空字符结束。空字符的 ASCII 码为 0，专门用来标记字符串的结尾，在程序中写作 `\0`。

```c++
// str1 没有结尾空字符，并不是一个字符串
char str1[5] = {'h', 'e', 'l', 'l', 'o'};

// str2 是一个字符串，字符串的长度包含 '\0'
char str1[6] = {'h', 'e', 'l', 'l', 'o', '\0'};
char str3[6] = "hello";  // 这里字符数组的长度是 6，因为有个 '\0'
```

char 数组更底层，效率可能会更高，但安全程度、方便程度不如 string，一般情况下，使用字符串建议用 string。但注意，C++ 字符串字面值常量默认类型是 char 数组，因此，在同时使用 string 变量和字符串常量（char 数组）时要小心，如两个字符串字面值常量拼接是没有这种操作的，只有 string 可以：`"hello" + "world"` 是 char 数组的拼接，不允许。


### 读取输入字符串
程序中往往需要一些交互操作，如果想获取从键盘输入的字符串，可以使用多种方法。

1. 使用输入操作符读取单词

标准库中提供了 `iostream`，可以使用内置的 `cin` 对象，调用重载的输入操作符 `>>` 来读取键盘输入。

```c++
string str;

// 读取键盘输入，遇到空白符停止
std::cin >> str;

std::cout << str;
```

这种方式的特点是：忽略开始的空白符，遇到下一个空白符（空格、回车、制表等）就会停止。所以如果我们输入 "hello world"，那么读取给 str 的只有 "hello"。

剩下的内容 "world" 其实也没有丢，而是保存在输入流的 “输入队列”里，如果我们想读取更多的输入信息，就需要使用更多的 string 对象来获取。

```c++
std::string str1, str2;

// 1. 将第一个字符串赋给 str1，遇到空格后，将第二个字符串赋给 str2
std::cin >> str1 >> str2;

std::cout << str1 << str2 << std::endl;
```

2. 使用 `geline` 读取一行

如果希望直接读取一整行输入信息，可以使用 `getline` 函数来替代输入操作符。

```c++
std::string str3;

// 2. 读取一行信息
// 不对读取回车符，直接丢掉回车符，不可以由 std::cin.get() 捕获
getline(std::cin, str3);
```

`getline` 函数有两个参数：一个是输入流对象 `cin`，另一个是保存字符串的 `string` 对象，它会一直读取输入流中的内容，直到遇到换行符为止，然后把所有内容保存到 `string` 对象中，所以现在可以完整读取一整行信息了。

3. 使用 `get` 读取字符

还有一种方法，是调用 `std::cin` 的 `get` 函数读取一个字符。

```c++
char ch;

// 3. 读取一个字符
ch = std::cin.get();  // 将捕获到的字符赋值给 ch
// or
std::cin.get(ch);
```

有两种方式：
- 调用 `cin.get()` 函数，不传参数，得到一个字符赋给 `char` 类型变量；
- 将 `char` 类型变量作为参数传入，将捕获的字符赋值给它，返回的是 `istream` 对象。

`get` 函数还可以读取一行内容，这种方式跟 `getline` 很相似，也可以读取一整行内容，以回车结束。主要区别在于，它需要把信息保存在一个 `char[]` 类型的字符数组中，调用的是 `cin` 的成员函数。

```c++
// get 读取一整行
char str4[20];

std::cin.get(str4, 20);
```

`get` 函数同样需要传入两个参数：一个是保持信息的字符数组，另一个是字符数组的长度。

这里还要注意其跟 `getline` 的另一个区别：键盘输入总是以回车作为结束的。

### 简单读写文件

实际使用中，我们往往会遇到读写文件的需求，这也是一种 IO 操作，整体用法跟命令行的输入输出非常类似。

C++ 的 IO 库中提供了专门用于文件输入的 `ifstream` 类和用于文件输出的 `ofstream` 类，要使用它们需要引入头文件 `fstream`. `ifstream` 用于读取文件内容，跟 `istream` 的用法类似，也可以通过输入操作符 `>>` 来读“单词”（空格分隔），通过 `getline` 函数来读取一行，通过 `get` 函数来读取一个字符：

```c++
#include<iostream>
#include<fstream>
#include<string>

int main() {
    // 1. 按照单词逐个读取
    std::ifstream input("../resource/input.txt"); // 读
    std::ofstream output("../resource/output.txt"); // 写
    std::string word;
    while (input >> word) {
        std::cout << word << std::endl;
        output << word;
    }
    std::cout << "======" << std::endl;
    
    // 2. 逐行读取
    std::ifstream input2("../resource/input.txt");
    std::ofstream output2("../resource/output2.txt");
    std::string line;
    while (getline(input2, line)) {
        std::cout << line << std::endl;
        output2 << line << "\n";
    }
    std::cout << "======" << std::endl;
    
    // 3. 逐字符读取
    std::ifstream input3("../resource/input.txt");
    std::ofstream output3("../resource/output3.txt");
    char ch;
    while (input3.get(ch)) {
        std::cout << ch << std::endl;
        output3 << ch;
    }
    std::cout << "======" << std::endl;
}
```

## 结构体
实际应用中，我们往往希望把很多不同的信息组合起来，“打包”存储在一个单元中。比如一个学生的信息，可能包含了姓名、年龄、班级、成绩等，这些信息的数据类型可能是不同的，所以数组和 `vector` 都无法完成这样的功能。

C/C++ 中提供了另一种更加灵活的数据结构---结构体。结构体是用户自定义的复合数据结构，里面可以包含多个不同类型的数据对象。

### 结构体的声明
声明一个结构体需要使用 `struct` 关键字，具体形式如下：

```c++
struct 结构体名
{
    类型1 数据对象1;
    类型2 数据对象2;
    类型3 数据对象3;
    ...
};
```

结构体中数据对象的类型和个数都可以自定义，这为数据表达提供了极大的灵活性。结构体可以说是迈向面向对象世界中“类”概念的第一步。

我们可以尝试定义一个“学生信息”的结构体。

```c++
#include<iostream>

// 结构体定义
struct StudentInfo
{
    string name;
    int age;
    double score;
};

// struct StudentInfo
// {
//     string name;
//     int age;
//     double score;
// }stu2, stu3 = {"xiaoming", 19, 65.6};

int main() {
    // 创建数据对象并初始化
    StudentInfo stu = {"zs", 18, 75.0};
    StudentInfo stu1{"lisi", 20, 83.0};

    StudentInfo stu4 = stu;
}
```

需要注意：
- 创建结构体变量对象时，可以直接用定义好的结构体名作为类型，相比 C 语言中的定义，这里省略了关键字 `struct`;
- 不同的初始化方式效果相同，在不同位置定义的对象作用域不同；
- 如果没有赋初始值，那么所有数据将被初始化为默认值；算术类型的默认值就是0；
- 一般在代码中，会将结构体的定义和对象的创建分开，便于理解和管理。

### 访问结构体中的数据

访问结构体变量中的数据成员，可以使用成员运算符（点号），后面跟上数据成员的名称。例如 `stu.name` 就可以访问 `stu` 对象的 `name` 成员。

这种访问内部成员的方式非常经典，后面要讲到的类的操作中，也会用这种方式访问自己的成员函数。

### 结构体数组

可以把结构体和数组结合起来，创建结构体的数组。顾名思义，结构体数组就是元素为结构体的数组，它的定义和访问跟普通的数组完全一样。

```c++
studentInfo s[2] = {
    {"xiaohong", 18, 92},
    {"xiaobai", 20, 82}
};

std::cout << s[0].name << std::endl;
std::cout << s[1].age << std::endl;
```

## 枚举

实际使用中，经常会遇到某个数据对象只能取有限个常量值的情况，比如一周有 7 天，一副扑克牌有 4 中花色等。对于这种情况，C++ 提供了另一种批量创建符号常量的方式，可以替代 `const`，这就是枚举类型 `enum`.

### 枚举类型的定义
枚举类型的定义和结构体非常像，需要使用 `enum` 关键字。

```c++
enum weak {
    Mon, Tue, Wed, Thu, Fri, Sat, Sun
};
```

与结构体不同的是，枚举类型内只有有限个名字，它们都各自代表一个常量，被称为“枚举量”。需要注意的是

- 默认情况下，会将整数值赋给枚举量；
- 枚举量默认从 0 开始，每个枚举量依次加 1； 所以上面的 week 枚举类型中，一周七天枚举量分别对应着 0 ~ 6 的常量值；
- 可以通过对枚举量赋值，显示地设置每个枚举量的值

### 枚举类型使用

使用枚举类型也很简单，创建枚举类型的对象后，只能将对应类型的枚举量赋值给它；如果打印它的值，将会得到对应的整数。

```c++
// 分别是 0， 1， 2， 10， 11， 12， 13
enum week {
    Mon, Tue, Wed, Thu = 10, Fri, Sat, Sun
}
week w1 = Mon;
week w2 = Tue;

// week w3 = 2; // 错误，类型不匹配，整型不能赋值给 week 类型
// 虽然 3 不在 week 定义的值里，但是可以灵活定义新值
week w3 = week(3); // 正确，int 类型强转为 week 类型后赋值

std::cout << w1 << w2 << w3 << std::end;
```

需要注意：
- 如果直接用一个整型值对枚举类型赋值，将会报错，因为类型不匹配
- 可以通过强制类型转换，将一个整型值赋值给枚举对象
- 最初的枚举类型只有列出的值是有效的，而现在c++通过强制类型转换，允许扩大枚举类型合法值的范围，不过一般使用枚举类型要避免直接强制赋值

## 指针

计算机中的数据都存放在内存中，访问内存的最小单元是“字节”（byte）。所有的数据，就保存在内存中具有连续编号的一串字节里。

指针是指向另外一种数据类型的复合类型，指针是C/C++中一种特殊的数据类型，它所保存的信息，其实是另外一个数据对象在内存中的地址。通过指针可以访问到指向的那个数据对象，所以这是一种间接访问对象的方法。

### 指针的定义

指针的定义语法：

```c++
类型* 指针变量;
```

这里的类型就是指针指向的数据类型，后面加上星号 *，然后跟指针变量的名称。指针在定义的时候可以不做初始化。相比一般的变量声明，指针看上去只是多了一个星号“`*`”而已。

```c++
int* p1; // 指向int类型数据的指针
long* p2; // 指向long类型数据的指针
std::cout << "p1 在内存中的长度为： " << sizeof(p1) << std::endl;
```

p1, p2 就是两个指针，分别指向 int 类型和 long 类型的数据对象。

指针的本质，其实就是一个整数表示的内存地址，它本身所占内存大小跟系统环境有关，而跟指向的数据类型无关。64位编译环境中，指针统一占8个字节，32位编译环境，指针占4个字节。

### 指针的用法

1. 获取对象地址给指针赋值

指针保存的是数据对象的内存地址，所以可以用地址给指针赋值，获取对象地址的方式是使用取地址操作符“`&`”。

```c++
int a = 1;
int b = 2;

int* p = &a; // 声明指针p，并指向变量a
p = &b; // 指针指向变量b
```

把指针当作一个变量，可以先指向一个对象，再指向另一个不同的对象。

2. 通过指针访问对象

指针指向数据对象后，可以通过指针来访问对象。访问方式是使用解引用操作符“`*`”。

```c++
int a = 3; // 定义变量a
int* p = &a; // 定义指针p，并指向变量a

*p = 9; // 将指针p指向的对象a的值修改为9
```

在这里由于p指向了a，所以*p可以等同于变量a.

### 无效指针、空指针和void*指针

1. 无效指针

定义指针后，如果不进行初始化，那么它的内容是不确定的（如可能是0xcccc）。如果这时把它的内容当成一个地址去访问，可能访问的是一个不存在的对象。可怕的是，如果访问到的是系统核心内存区域，修改其中内容会导致系统崩溃。这样的指针是无效指针，也被叫做野指针。

```c++
int* p1;
*p1 = 100; // 危险，指针没有初始化，不明确其指向的内存是哪里或哪个变量，修改可能造成系统奔溃
```

指针非常灵活非常强大，但野指针非常危险。所以建议使用指针的时候，一定先初始化，让它指向真是的对象。

2. 空指针

如果定义了一个指针，但确实不知道它现在要指向那个对象，这时可以把它初始化为空指针，空指针不指向任何对象。

```c++
int* p = nullptr; // 空指针字面值
p = NULL; // 预处理变量
p = 0; // 零值

int zero = 0;
// p = zero; // 错误，int变量不能赋值给指针，因为指针的类型是int*，不是int
```

空指针有几种定义方式：
- 使用字面值 nullptr，这是C++11引入的方式，推荐使用；
- 使用预处理变量NULL，这是老版本的方式；
- 直接使用0值；
- 不能直接用整型变量给指针赋值，即使值为0也不行。因为它有数据类型int和指针类型不一致

所以可以看出，空指针所保存的其实就是0值，一般把它叫做“0地址”。这个地址在内存中也是真实存在的，所以不允许访问。

3. void* 指针

一般来说，指针的类型必须和指向的对象类型匹配，否则就会报错。不过有一种指针比较特殊，可以用来存放任意对象的地址，这种指针类型就是 void*。

```c++
int i = 10;
string s = "hello";

void* p = &i;
p = &s;

std::cout << "p = " << p << std::endl;
std::cout << "the length of p = " << sizeof(p) << std::endl;
// std::cout << "*p = " << *p << std::endl; // 错误，不能通过 void* 指针访问对象
```

`void*` 指针表示只知道“保存了一个地址”，至于这个地址对应的数据对象是什么类型并不清楚。所以不能通过 `void*` 指针访问对象。一般 `void*` 指针只用来比较地址或者作为函数的输入输出。

### 指向指针的指针
指针本身也是一个数据对象，也有自己的内存地址，所以可以让一个指针保存另一个指针的地址，这就是“指向指针的指针”，有时也叫做“二级指针”；形式上可以用连续两个星号“`**`”来表示。类似地，如果是三级指针就是“`***`”，表示指向二级指针的指针。

```c++
int i = 1024;
int* pi = &i; // pi 是一个指针，指向 int 类型的数据
int** ppi = &pi; // ppi 是一个二级指针，指向一个 int* 类型的指针
```

### 指针和常量 const

指针可以和 const 修饰符结合，这可以有两种形式：一种是指针指向的是一个常量；另一种是指针本身是一个常量。

1. 指向常量的指针

指针指向的是一个常量，所以只能访问数据，不能通过指针对数据进行修改。不过指针本身是变量，可以指向另一个数据对象（不要求必须是常量）。这时应该把 const 加在类型前。

```c++
const int c = 10, d = 20;

// int* p = &c; // 错误，类型不匹配。因为 p 只能指向 int 类型的变量，而不是常量
const int* p = &c; // 正确，p是指向常量的指针，类型为 const int*

p = &d; // 正确，因为指针p是变量，可以指向另一个常量

int i = 1024;
p = &i; // p 也可以指向变量
// *p = 2048; // 错误，不能通过 p 更改数据对象
```

这里发现，p 是一个指向常量的指针，但其实把一个变量 i 的地址赋给它也是可以的。编译器只是不允许通过指针去间接更改数据对象。

- 指向常量的指针不能修改对象的值
- 指向的对象类型必须匹配

2. 指针常量（const 指针）

指针本身是一个数据对象，所以也可以区分变量和常量。如果指针本身是一个常量，就意味它保存的地址不能更改，也就是它永远指向同一个对象。而数据对象的内容可以通过指针改变。这种指针一般叫做指针常量。

指针常量在定义的时候，需要在星号`*`后、标识符前加上 const。（从左往右直到`*`来判断指针指向的对象的数据类型）

```c++
int i = 3;
int* const p = &i;

*p = 9; // 通过指针修改对象的值
```

常量指针常量：`const int* const p` 表示指向 `const int` 对象的指针常量 `const`，其一旦指向初始化就不能更改，因为其是（指针中的）常量，而且，它指向的对象也不能被修改值，因为它指向的对象是 `const int`。

### 指针和数组

1. 数组名

用到数组名时，编译器一般都会把它转换成指针，这个指针就指向数组的第一个元素。所以我们也可以用数组名来给指针赋值。

本质上，数组就是一个指针。

```c++
int arr[] = {1, 2, 3, 4, 5};
std::cout << &arr[0] << std::endl;

int* parr = arr; // 直接用数组名给指针赋值
std::cout << "*parr = " << *pia << std::endl; // 指针指向的数据就是 arr[0]
```

也正是因为数组名被认为是指针，所以不能直接使用数组名对另一个数组赋值，数组也不允许这样的直接拷贝：

```c++
int arr[] = {1, 2, 3, 4, 5};

// int arr2[5] = arr; // 错误，数组不能直接拷贝

int* p = arr;

std::cout << "*p = " << *p << std::endl; // 就是arr指向的第一个元素值
*p = 100;
```

2. 指针运算

如果对指针 p 做加 1 操作，我们会发现它保存的地址直接加了 4，这其实是指向了下一个 int 类型的数据对象：

```c++
p + 1; // 指向的是 arr[1]

*(p + 1); // 访问 arr[1]
```

所谓的“指针运算”，就是直接对一个指针加或减一个整数值，得到的结果仍然是指针。新指针指向的数据元素，跟原指针指向的相比移动了对应个数据单位。

3. 指针和数组下标

我们知道，数组名 arr 其实就是指针。这就带来了非常有趣的访问方式：

```c++
*arr; // 表示 arr[0]
*(arr + 1); // 表示arr[1]
```

这是通过指针访问数组元素，效果跟使用下标运算符 arr[0], arr[1] 是一样的。


4. 指针数组和数组指针

指针和数组这两种类型可以结合在一起，这就是“指针数组”和“数组指针”。
- 指针数组：一个数组，它的所有元素都是相同类型的指针；
- 数组指针：一个指针，指向一个数组的指针；

```c++
int arr[] = {1, 2, 3, 4, 5};

int* p[5]; // 指针数组，里面有5个元素，每个元素都是一个 int 指针
int( *p1)[5]; // 数组指针[指向数组的指针]，指向一个 int 数组，数组包含5个元素

std::cout << "指针数组的大小：" << sizeof(p) << std::endl; // 40
std::cout << "数组指针的大小：" << sizeof(p1) << std::endl; // 8

p[0] = arr; // p 中第一个元素，指向 arr 的第一个元素
p[1] = arr + 1; // p 中第二个元素，指向 arr 的第二个元素

p1 = &arr; // p1 指向了 arr 整个数组

std::cout << "arr = " << arr << std::endl;
std::cout << "*arr = " << *arr << std::endl; // arr解引用，得到 arr[0]
std::cout << "arr + 1 = " << arr + 1 << std::endl;
std::cout << "p1 = " << p1 << std::endl;
std::cout << "p1 = " << *p1 << std::endl;
std::cout << "p1 + 1 = " << p1 + 1 << std::endl;
```

## 引用

在C++中为数据对象另外起一个名字就叫做引用（reference）。

### 引用的用法

在做声明时，在变量的名前加上“`&`”符号，表示它是另一个变量的引用。引用必须被初始化。

```c++
int a = 10;
int& ref = a; // ref 是 a 的引用，就是 a 的别名，操作 ref 就等于操作 a
// int& ref2;  // 错误，没有被初始化
std::cout << "a的地址为：" << &a << std::endl;
std::cout << "ref的地址为：" << &ref << std::endl;

ref = 15; // 相当于 a = 15

int b = 20;
// ref 没有绑定到 b，而是把 b 的值赋给了 a （ref 的绑定）
ref = b; // 相当于 a = b，影响是 a 的值变为 b 的值，ref 的地址还是 a 的地址，引用 a 后不能再变

int& ref0 = 10; // 错误，不能对字面值常量进行引用

double d = 2.5;
int&  refd = d; // 错误，引用类型必须和绑定的类型一样才行
```

引用本质上就是一个别名，它本身不是数据对象，所以本身不会存储数据对象，而是和初始值绑定在一起，绑定之后就不能再绑定其他对象了。

定义了引用之后，对引用做的所有操作，就像直接操作绑定的原始对象一样。所以，引用也是一种间接访问数据对象的方式。

引用既然是别名，那么根据这个别名再另起一个别名也是可以的

```c++
// 引用的引用
int& ref2 = ref;

// 此时，ref2, ref 都是变量 a 的引用或别名，它们三个的地址都是一样的
```

引用的引用是把引用作为另一个引用的初始值，其实就是给原来绑定的对象又绑定了一个别名，这两个引用绑定的是同一个对象。

### 对常量的引用

可以把引用绑定到一个常量上，这就是对常量的引用。对常量的引用就是对常量起别名，绑定的对象不能修改，所以不能做赋值操作：

```c++
const int zero = 0;

const int& ref = zero; // 常量的引用
ref = 1; // 错误， ref 是 zero 的引用，就是它的别名，常量不能进行值的修改

int& ref0 = zero; // 错误，类型不匹配，必须是 const int& 才可以引用 const int 变量
```

对常量的引用有时也会直接简称常量引用，因为引用只是别名，本身不是数据对象。所以只能代表对一个常量的引用，而不会像常量指针那样引起混淆。

**常量引用和普通变量的引用不同，它的初始化要求宽松很多，只要是可以转换成它指定类型的所有表达式，都可以用来做初始化**。

```c++
const int& ref = 10; // 正确，可以用字面值常量做初始化

int i = 35;
const int&  cref = i; // 正确，可以用一个变量做初始化

double d = 3.14;
const int& crefd = d; // 正确，d会先转成 int 类型，引用绑定的是一个临时量
// 因为引用到不同数据类型的变量，需要先进行类型转换
// 此时，引用和原变量不再是同地址、可能值也不同
```

### 指针和引用

从上面可以看出，常量引用和指针常量有很多类似的地方，它们都可以绑定或指向一个常量，也可以绑定或指向一个变量，但不可以去修改对应的变量对象。

1. 引用和指针常量

事实上，引用的行为非常类似于指针常量，也就是只能指向唯一的对象、不能更改的指针

```c++
int a = 10;

// 引用的行为和指针常量非常类似
int& r = a;
int* const p = &a;

// 两者都能改变变量 a 的值
r = 10;
*p = 30;
```

指针常量会分配内存空间，引用不会；两者改变原变量的方式不同，指针变量必须要解引用。

为指针绑定引用：

```c++
int a = 10;

int* ptr = &a;
int*& pref = ptr; // 指针的引用

*pref = 100; // 改变了a的值
```

没有指向引用`ref`的指针：`int&* rptr = &ref`，因为引用就是一个别名，没有内存地址。

```c++
int a = 10;
int& ref = a;

int&* rptr = &ref; // 错误，ref 是引用，没有内存地址
```

# 函数

函数其实就是封装好的代码块，并且指定一个名字，调用这个名字就可以执行代码块并返回一个结果。

## 函数基本知识

### 函数的定义

一个完整函数的定义主要包括以下部分：
- 返回类型：调用函数之后，返回结果的数据类型；
- 函数名：用来命名代码块的标识符，在当前作用域内唯一；
- 参数列表：参数表示函数调用时需要传入的数据，一般叫做形参，放在函数名后的小括号内，可以有0个或多个，用逗号隔开；
- 函数体：函数要执行的语句块，用花括号括起来。

函数一般都是一个实现了固定功能的模块，把参数看作输入，返回结果看出输出。函数就是一个输入到输出的映射关系。

简单函数示例：

```c++
int square(int x) {
    int y = x * x;
    return y;
}
```

使用流程控制语句 return，就可以返回结果。

### 函数调用

调用函数时，使用的是“调用运算符”，就是跟在函数名后面的一对小括号。括号内是用逗号隔开的参数列表。

这里的参数不是定义时的形参，而是为了初始化形参传入的具体值；为了跟函数定义时的形参列表区分，把它叫做“实参”。

调用表达式的类型就是函数的返回类型，值就是函数执行返回的结果。

需要注意的是：

- 实参是形参的初始值，函数调用时传入实参，相当于执行了初始化操作，实参的类型必须跟形参的类型匹配；
- 实参的个数必须跟形参一致，如果有多个形参，要按照位置顺序一一对应；
- 如果函数本身没有参数，参数列表可以为空，但空括号不能省略；
- 形参列表中多个参数用逗号分隔，每个都要带上类型，类型相同也不能省略；
- 如果函数不需要返回值，可以定义返回类型为 void;
- 函数返回类型不能是数组或函数。

### 局部变量的声明周期

在 C++ 中，作用域指的是变量名字的可见范围，变量不可见，并不代表变量所指代的数据对象就销毁了。这是两个不同的概念：
- 作用域：针对名字而言，是程序文本中的一部分，名字在这不分可见
- 声明周期：针对数据对象而言，是程序在执行过程中，对象从创建到销毁的时间段。

基于作用域，变量可以分为“局部变量”和“全局变量”，对于全局变量而言，名字全局可见，对象也只有在程序结束时才销毁。

而对于局部变量代表的数据对象，基于生命周期，又可以分为“自动对象”和“静态对象”。

- 自动对象

平常代码中定义的普通局部变量，声明周期为在程序执行到变量定义语句时创建，在程序运行到当前块末尾时销毁。这样的对象成为自动对象。

形参也是一种自动对象，形参定义在函数体作用域内，一旦函数终止，形参也就被销毁了。

对于自动对象来说，它的声明周期和作用域是一致的。

- 静态对象

如果希望延长一个局部变量的生命周期，让它在作用域外仍然保留，可以在定义局部变量时加上 `static` 关键字，这样的对象叫做局部静态对象。

局部静态对象只有局部的作用域，在块外依然是不可见的，但是它的声明周期贯穿整个程序运行过程，只有在程序结束时才被销毁，这一点与全局变量类似。

```c++
// 显示函数本身被调用多少次的函数
int callCount()
{
    // 静态对象能够保存“前世记忆”
    static int cnt = 0; // 静态对象只会创建一次
    std::cout << "我被调用了 " << ++cnt << "次" << std::endl;
    return cnt;    
}

int main()
{
    for(int i = 0; i < 3; ++i)
    {
        std::cout << callCount() << std::endl;
    }
}
```

可以发现，静态对象只在第一次执行到定义语句时创建出来，之后即使函数执行结束，它的值依然保持；下一次函数调用时，不会再次创建、也不会重新赋值，而是直接在之前的值基础上继续叠加。

静态对象和自动对象应用的场景不同，所以它们存放的内存区域也是不一样的。静态对象如果不在代码中做初始化，基本类型会被默认初始化为0值。

### 函数声明

如果我们将一个函数放在主函数后面，就会出现运行错误：找不到标识符。这是因为函数和变量一样，使用之前必须要做声明。函数只有一个定义，可以定义在任何地方；如果需要调用函数，只需要在调用前做一个声明，告诉编译器“存在这个函数”就可以了。

函数声明的方式，和函数的定义非常相似；区别在于声明时不需要把函数体写出来，用一个分号替代就可以了。

```c++
#include <iostream>

// 声明函数
int square(int x);
// or
// int square(int);

// 主函数
int main()
{
    int n = 6;
    std::cout << n << "的平方是 " << square(n) << std::endl;
}

// 定义函数
int square(int x)
{
    return x*x;
}
```

事实上，由于没有函数体的执行过程，所以形参的名字也完全不需要，可以省略。可以直接这样声明一个函数：

```c++
int square(int);
```

函数声明中包含了返回类型、函数名和形参类型，这就说明了调用这个函数所需要的所有信息。函数声明也被叫做“函数原型”。

一般情况下，把函数声明放在头文件中会更加方便。

### 分离式编译和头文件

1. 分离式编译

当程序越来越复杂，我们就会希望代码分散到不通的文件来做管理。C++支持分离式编译，这就可以把函数单独放在一个文件，独立编译之后链接运行。

比如，可以把复制字符串的函数单独保存成一个文件`copy_string.cpp`:

```c++
#include <iostream>
#include <string>

// 复制字符串
std::string copyStr(std::string str, int n)
{
    /**
     * 复制字符串 str 成 n 倍
    */
   std::string result;
   while (n > 0)
   {
        result += str;
        --n;
   }
   return result;
}
```

然后只要在主函数调用之前做声明就可以了：

```c++
#include <iostream>

// 声明函数
string copyStr(string, int);

int main()
{
    int n = 6;
    std::cout << copyStr("hello", n) << std::endl;
    return 0;
}
```

2. 编写头文件

对于一个项目，有些定义可能是所有文件共用的，比如一些常量、结构体/类，以及功能性的函数。于是每次需要引入时，都得做一堆声明——这显然太麻烦了。

一个好方法是，把它们定义在同一个文件中，需要时用一句 `#include` 统一引入就可以了，就像使用库一样。这样的文件以 `.h` 作为后缀，被称为“头文件”。

比如我们可以把之前的一些功能性的函数，都放在一个叫做 `utils.h` 的头文件中：

```c++
#pragma once
#include <string>

// 平方函数
int square(int x)
{
    int y = x * x;
    return y;
}

// 立方和函数
int cubeSum(int x, int y)
{
    return pow(x, 3) + pow(y, 3);
}

// 阶乘函数
int factorial(int n)
{
    int result = 1;
    for (int i = 1; i <=n; ++i)
    {
        result *= i;
    }
    return result;
}
```

## 参数传递

函数在每次调用时，都会重新创建形参，并且用传入的实参对它进行初始化。形参的类型，决定了形参和实参交互的方式，也决定了函数的不同功能。

可以先回忆一下对变量的初始化：对一个变量做初始化，如果用另一个变量给它赋初值，意味着值的拷贝，也就是说，此后这两个变量各自一份数据，各自管理，互不影响。而如果是定义一个引用，绑定另一个变量做初始化，并不会引发值的拷贝，引用和原变量管理的是同一个数据对象。

```c++
int i = 0;
int j = i;
j = 9; // i 的值仍然是 0

int& k = i;
k = 9; // i 的值也变为 9
```

参数传递和变量的初始化类似，根据形参的类型可以分为两种方式：传值（value）和传引用（reference）.

### 传值参数

直接将一个实参的值，拷贝给形参做初始化的传参方式，就被称为“值传递”， 这样的参数被称为“传值参数”。

```c++
int square(int x)
{
    return x * x;
}

int main()
{
    int n = 6;
    std::cout << n << "的平方是：" << square(n) << std::endl;
}
```

在上面平方函数的调用中，实参 `n` 的值 6 被拷贝给了形参 `x`。

- 传值的困扰

值传递这种方式非常简单，但是面对这样的需求会有些麻烦：传入一个数据对象，让它经过函数处理之后发生改变。例如，传入一个整数 x，调用之后它自己的值要加1。

```c++
void increase(int x)
{
    ++x;
}

int main()
{
    int n = 6;
    increase(n); // n 的值不会增加
}
```

这样做并不能实现需求。因为实参 `n` 的值是拷贝给形参 `x` 的，之后 `x` 的任何操作，都不会改变 `n`。想要达到效果，可以使用指针：

```c++
void increase(int *x)
{
    ++(*x);
}

int main()
{
    int n = 0;
    increase(&n); // n = 1
    increase(&n); // n = 2
}
```

### 传引用参数

使用指针形参可以解决值传递的问题，不过这种方式函数定义显得有些繁琐，每次调用还需要记住传入变量的地址，使用起来不够方便。

- 传引用方便函数调用

C++ 新增了引用的概念，可以替换必须使用指针的场景。采用引用作为函数形参，可以使函数调用更加方便。这种传参方式叫做“传引用参数”。

```c++
void increase(int &x)
{
    ++x;
}

int main()
{
    int n = 0;
    increase(n); // n = 1
}
```

由于使用了引用作为形参，函数调用时就可以直接传入 `n` 的值，而不用传地址了。`x` 只是 `n` 的一个别名，修改 `x` 就修改了 `n`。对比可以发现，这段代码相比最初尝试写出的传值实现，只是多了一个引用声明 `&` 而已。

- 传引用避免拷贝

使用引用还有一个非常重要的场景，就是不希望进行值拷贝。实际应用中，很多时候函数要操作的对象可能非常庞大，如果做值拷贝会使得效率大大降低，这是使用引用就是一个好方法。

比如，想要定义一个函数比较两个字符串的长度，需要将两个字符串作为参数传入，因为字符串有可能非常长，直接做值拷贝并不是一个好选择，最好的方式就是传递引用。

```c++
bool isLonger(const string &str1, const string &str2)
{
    return str1.size() > str2.size();
}
```

- 使用常量引用做形参

在上面的例子中，比较两个字符串的长度，并不会更改字符串本身的内容，所以可以把形参定义为常量引用。

这样的好处是，既避免了对数据对象可能得更改，也扩大了调用时能穿的实参的范围。因为只爱你讨论过常量引用的特点，可以用字面值常量对它做初始化，也可以用变量做初始化。

所以，**在代码中一般要尽量使用常量引用作为形参**。

### 数组形参

之前介绍过，数组是不允许做直接拷贝的，所以如果想要把数组作为函数的形参，使用值传递的方式是不可行的。与此同时，数组名可以解析成一个指针，所以可以用传递指针的方式来处理数组。

比如一个简单的函数，需要遍历 `int` 类型数组所有元素并输出，就可以这样声明：

```c++
void printArr(const int*); // 指向 int 类型常量的指针
void printArr(const int[]);
void printArr(const int[5]);
```

由于只是遍历输出，不需要修改数组内容，所以这里使用了 const。

以上三种声明方式，本质上是一样的，形参的类型都是 `const int *`；虽然第三种方式指定了数组长度，但由于编译器会把传入的数组名解析成指针，事实上数组长度还是无法确定的。

这就带来另一个问题，在函数中，遍历元素时怎样确定数组的结束？

1. 规定结束标记

一种简单思路是，规定一个特殊的“结束标记”，遇到这个标记就代表当前数组已经遍历完了。典型代表就是 C 语言风格的字符串，是以空字符 `\0` 为结束标志的 char 数组。

这种方式比较麻烦，而且太多特殊规定也不适合像 int 这样的数据类型。

2. 把数组长度作为形参

除指向数组的指针外，可以再增加一个形参，专门表示数组的长度，这样就可以方便地遍历数组了。

```c++
void printArr(const int *arr, int size)
{
    for (int i = 0; i < size; ++i)
    {
        std::cout << arr[i] << "\t";
    }
    std::cout << std::endl;
}

int main()
{
    int n = 6;
    int arr[n] = {1, 2, 3, 4, 5};
    printArr(arr, n);
}
```

3. 使用数组引用作为形参

之前的方法依赖指针，所以都显得比较麻烦，更加方便的做法还是用引用来替代指针的功能。

C++ 允许使用数组的引用作为函数形参，这样一来，引用作为别名绑定在数组上，使用引用就可以直接遍历数组了。

```c++
// 使用数组引用作为形参
void printArr(const int(&arr)[6]) // 这个长度是真正有效的
{
    for (int num: arr)
    {
        std::cout << num << "\t";
    }
    std::cout << std::endl;
}

int main()
{
    int arr[5] = {1, 2, 3, 4, 5};
    printArr(arr);
}
```

### 可变形参

有时候我们并不确定函数中应该有几个形参，这时就需要使用“可变形参”来表达。

C++ 中表示可变形参的方式主要有三种：
- 省略符（...）：兼容C语言的用法，只能出现在形参列表的最后一个位置；
- 初始化列表 initializer_list: 跟 vector 类似，也是一种标准库模板类型；initializer_list对象中的元素只能是常量值，不能更改；
- 可变参数模板：这是一种特殊的函数。

## 返回类型

函数可以通过 `return` 语句，终止函数的执行并“返回”函数调用的地方；并且可以给定返回值。返回值的类型由函数声明时的“返回类型”决定。

`return` 语句可以有两种形式：

```c++
return; // 直接返回，无返回值
return 表达式; // 返回表达式的值
```

### 无返回值

当函数返回类型为 `void` 时，表示函数没有返回值。可以在函数中需要返回时直接执行 `return` 语句，也可以不写。因为返回类型为 `void` 的函数执行完最后一句，会自动加上 `return` 返回。

例如，可以将之前“两元素值互换”的代码，包装成一个函数。可以先做一个判断，如果两者相等就直接返回，这样可以提高允许效率。

```c++
// 元素互换
void swap(int &x, int &y)
{
    if (x == y)
    {
        return; // 不需要交换，直接返回
    }
    int temp = x;
    x = y;
    y = temp;
}
```

### 有返回值

如果函数返回类型不为 `void`，那么函数必须执行 `return`，并且每条 `return` 必须返回一个值。返回值的类型应该跟函数返回类型一致，或者可以隐式转换为一致。

1. 函数返回值的原理

函数在调用点会创建一个“临时量”，用来保存函数调用的结果。当使用 `return` 语句返回时，就会用返回值去初始化这个临时量。所以返回值的相关规则，跟变量或者形参的初始化是一致的。

之前写过一个“比较字符串长度”的 `isLonger` 函数，我们可以稍微修改，让它可以返回较长的那个字符串：

```c++
string longerStr(const string &str1, const string &str2)
{
    return str1.size() > str2.size() ? str1 : str2;
}

int main()
{
    string str1 = "hello";
    string str2 = "hello world!";
    std::cout << longerStr(str1, str2) << std::endl; // longerStr(str1, str2) 处会创建临时变量，如果用引用传递可以更高效，相对于值拷贝
}
```

调用这个函数，经过判断发现 `str2` 更长，这是执行 `return` 将返回 `str2`，由于返回类型是 `string`，所以将用 `str2` 对一个 `string` 临时量做初始化，执行的是只拷贝（当函数返回值类型是 `string`）是 `str2` 的一个副本；

2. 返回引用类型

对于 `string` 对象，显然做值拷贝并不高效。所以我们依然可以借鉴之前的经验，使用引用类型来做返回值的传递，这样就可以避免值拷贝。

```c++
// 返回一个 string 常量对象的引用，不做值拷贝
const string & longerStr(const string &str1, const string &str2)
{
    return str1.size() > str2.size() ? str1 : str2;
}
```

这里我们同样把返回值定义成了常量引用，方式和作用跟形参完全一样。

上面函数返回的是形参 `str1` 和 `str2` 的引用；而函数中的形参本身又是引用类型，所以最终是实参对象的引用。

而如果返回的是一个函数内局部变量的引用，比如：

```c++
const string & f()
{
    string str = "test";
    return str;
}
```

这样做是不安全的，因为 `str` 是函数内部的局部对象，函数执行完成后就销毁了。而返回值是它的引用，相当于引用了一个不存在的对象，这可能会导致无法预料的问题。

所以，函数返回引用类型时，不能返回局部对象的引用，同样道理，也不应该返回指向局部对象的指针。

3. 返回类对象后连续调用

如果函数返回一个类的对象，那么我们可以继续调用这个对象的成员函数，这样就形成了“链式调用”，例如：

```c++
longerStr(str1, str2).size();
```

调用运算符，和访问对象成员的点运算符优先级相同，并且满足左结合律。所以链式调用就是从左向右依次调用，代码可读性会更高。

### 主函数的返回值

主函数 `main` 是一个特殊函数，它是我们执行程序的入口，所以 C++ 中对主函数的返回值也有特殊的规定：即使返回类型不是 `void`，主函数也可以省略 `return` 语句。如果主函数执行到结尾都没有 `return` 语句，编译器就会自动插入一条：

```c++
return 0;
```

主函数的返回值可以看做程序运行的状态指示器：返回0表示运行成功；返回非0值则表示失败。非0值具体的含义依赖机器决定。

### 返回数组指针

与形参类似，由于数组“不能拷贝”的特点，函数也无法直接返回一个数组。同样的，我们可以使用指针或者引用来实现返回数组的目标；通常会返回一个数组指针。

```c++
int arr[5] = {1, 2, 3, 4, 5};
int* pa[5]; // 指针数组，pa 是包含 5 个 int 指针的数组
int (*ap)[5] = &arr; // 数组指针，ap  是一个指针，指向长度为 5 的 int 数组
int (*fun(int x))[5]; // 函数声明，fun 返回值类型为数组指针
```

这里对函数 `fun` 的声明，进行层次解析：
- `fun(int x)`：函数名为 `fun`，形参为 `int` 类型的 `x`；
- `(*fun(int x))`：函数返回的结果，可以执行解引用操作，说明是一个指针；
- `(*fun(int x))[5]`：函数返回结果解引用之后是一个长度为 5 的数组，说明返回类型是数组指针；
- `int (*fun(int x))[5]` ：数组中元素类型为 `int`

数组指针的定义比较繁琐，为了简化这个定义，我们可以使用关键字 `typedef` 来定义一个类型的别名：

```c++
typedef int arrayT[5]; // 类型别名，arrayT 代表长度为 5 的 int 数组
arrayT* func2(int x); // func2的返回类型是指向 arrayT 的指针
```

C++11 新标准还提供了另一种简化方式，用一个 `->` 符号跟在形参列表后面，再把类型单独提出来放到最后。这种方式叫做“尾置返回类型”。

```c++
auto fun3(int x) -> int(*)[5]; // 尾置返回类型
```

因为返回类型放到了末尾，所以前面的类型用了自动推断的 `auto`.

## 递归

如果一个函数调用了自身，这样的函数就叫做“递归函数”（recursive function）。

### 递归的实现

递归是调用自身，如果不加限制，这个过程是不会结束的。函数永远调用自己下去，最终会导致程序栈空间耗尽。所以在递归函数中，一定会有某种“基准情况”，这个时候不会调用自身，而是直接返回结果。基准情况的处理保证了递归能够结束。

递归是不断自我重复，这一点和循环有相似之处。事实上，递归和循环往往可以实现同样的功能。

比如之前求阶乘的函数，用递归：

```c++
#include <iostream>
using namespace std;

// 递归方式求阶乘
int factorial(int n)
{
    if (n == 1)
    {
        return 1;
    }
    else
    {
        return n * factorial(n - 1);
    }
}

```

这里基准情况是 `n == 1`，也就是当 `n` 不断减小，直到 1 时就结束递归直接返回。

递归至少需要额外的栈空间开销，所以递归的效率往往会比循环低一些，不过对于很多数学问题，递归可以让代码非常简洁。

### 经典递归——斐波那契数列

斐波那契数列（Fibonacci sequence），又称黄金分割数列，指的是数列：

```bash
1, 1, 2, 3, 5, 8, 13, 21, 34, ...
```

它的规律是：从第三个数字开始，当前数字是之前两个数字之和。在数学上，斐波那契数列的递推方法：

$$
F(0) = 1, F(1) = 1, F(n) = F(n - 1) + F(n - 2), (n \geq 2, n\in N^*)
$$

C++ 实现：

```c++
#include <iostream>
using namespace std;

int fib(int n)
{
    if (n == 1 | n == 2)
    {
        return 1;
    }
    else
    {
        return fib(n - 2) + fi(n - 1);
    }
}
```

## 应用案例

### 二分查找

二分查找也成折半查找（binary search），它是一种效率较高的查找方法，前提是数据对象必须先排好序。二分查找采用的是“分治”策略，它充分利用元素见的次序关系。

```c++
#include <iostream>

using namespace std;

int search(const int (&a) [10], int start, int end, int target)
{
    // 基准情况：目标值超出范围，或者 start > end，说明没有找到
    if (target < a[start] || target > a[end] || start > end)
    {
        return -1;
    }

    // 取二分中间坐标
     int mid = (start + end) / 2;
    // 比较中间值和目标值大小
    if (a[mid] == target)
    {
        return mid; // 找到了
    }
    else if (a[mid] > target)
    {
        return search(a, start, mid - 1, target); // 比目标值大，在更小的部分找
    }
    else
    {
        return search(a, mid + 1, end, target); // 比目标值小，在更大的部分找
    }
}
```

### 快速排序

前面介绍的选择排序和冒泡排序都是使用两层 `for` 循环遍历数组，效率较低。改进思路是：通过一次扫描，将待排记录分割成独立的两部分，其中一部分的值全比另一部分的小，接下来分别对这两部分继续进行排序，最终全部排完。这种算法更加高效，被成为“快速排序”。

1. 选取一个“支点”数据，作为分区标准；
2. 分区，找到支点位置，之前都比它小，之后都比它大；
3. 再对每个分区部分递归进行处理。

可以看出，快排也应用了分治思想，一般会用递归来实现。

```c++
#include <iostream>

using namespace std;

void swap(int (&)[10], int, int);
int partition(int (&)[10], int, int);
void quickSort(int (&)[10], int, int);
void printArr(const int (&)[10]);

int main()
{
    int arr[10] = {23, 45, 18, 6, 11, 19, 22, 18, 123, 9};
    printArr(arr);

    int size = sizeof(arr) / sizeof(arr[0]);
    quickSort(arr, 0, size - 1);
    printArr(arr);
}

// 交换数组中的两个元素
void swap(int (&arr)[10], int i, int j)
{
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

// 按照支点进行分区的函数
int partition(int (&arr)[10], int start, int end)
{
    // 选取支点
    int pivot = arr[start];
    // 指定指向数组头尾元素的“指针”
    int left = start, right = end;
    // 只要 left 与 right 不相遇，left 向右移动，right想左移动
    while (left < right)
    {
        // 左指针不停右移，找到一个比支点大的值
        while (arr[left] <= pivot && left < right)
        {
            ++left;
        }
        // 右指针不停左移，找到一个比支点小的值
        while (arr[right] >= pivot && left < right)
        {
            --right;
        }
        // 左右互换
        swap(arr, left, right);
    }

    // 判断指针相遇位置的值，跟支点值的大小关系
    if (arr[left] <= pivot)
    {
        // 比支点值小，就直接换到数组的头位置
        swap(arr, start, left);
        return left;
    }
    else
    {
        // 比支点值大，就将前一个位置的元素直接换到数组的头位置
        swap(arr, start, left - 1);
        return left - 1;
    }
}

// 快速排序函数
void quickSort(int (&arr)[10], int start, int end)
{
    /**
     * 递归实现数组快速排序
     */
    // 基准情况，首尾两个指针相等
    if (start >= end)
    {
        return;
    }
    // 支点
    int pivot = partition(arr, start, end);
    // 对支点左右部分进行递归调用
    quickSort(arr, start, pivot - 1);
    quickSort(arr, pivot + 1, end);
}

// 打印输出数组
void printArr(const int (&arr)[10])
{
    for (int num : arr)
    {
        cout << num << "\t";
    }
    cout << endl;
}
```

# 函数高阶

函数式模块化编程思想的重要体现，相对于C语言，C++提供了很多新的函数特性。

## 内联函数

内联函数是C++为了提高允许速度做的一项优化。

函数让代码更加模块化，可重用性、可读性大大提高。不过函数也有一个缺点：函数调用需要执行一系列额外操作，会降低程序运行效率。

为了解决这个问题，C++引入了“内联函数”的概念。使用内联函数时，编译器不再去做常规的函数调用，而是把它在调用点上“内联”展开，也就是直接用函数代码替换函数调用。

### 内联函数的定义

定义内联函数，只需要在函数声明或函数定义前加上 `inline` 关键字。

如：

```c++
inline const string& longerStr(const string& str1, const string& str2)
{
    return str1.size() > str2.size() ? str1 : str2;
}
```

当我们试图打印输出调用结果时：

```c++
cout << longerStr(str1, str2) << endl;
```

编译器会自动把它展开为

```c++
cout << (str1.size() > str2.size() ? str1 : str2) << endl;
```

这样就大大提高了运行效率。

### 内联函数和宏

内联函数是 C++ 新增的特性。在 C 语言中，类似功能是通过预处理语句 `#define` 定义“宏”来实现的。

然后C中宏本身并不是函数，无法进行值传递，它的本质是文本替换，我们一般只用宏来定义常量。用宏实现函数的功能会比较麻烦，而且可读性较差，所以在C++中，一般都会用内联函数来取代C中的宏。

## 默认实参

在有些场景中，当调用一个函数时，它的某些形参一般都会被赋一个固定的值。为了简单起见，我们可以给它设置一个默认值，这样就不用每次都传同样的值了。

这种会反复出现的默认值，称为函数的默认实参。当调用了一个有默认实参的函数时，这个实参可以省略。

### 定义带默认实参的函数

我们用一个 `string` 对象表示学生基本信息，调用函数时应传入学生的姓名、年龄和平均成绩。对于这些参数，我们可以指定默认实参：

```c++
#include <iostream>
#include <string>
using namespace std;

string stuInfo(string name = "", int age = 18, double score = 60)
{
    string info = "student's name: " + name + "\t age: " + to_string(age) + "\t score: " + to_string(score);
    return info;
}
```

定义默认实参，形式上就是给形参做初始化。这里在整合学生信息时，使用了运算符 `+` 进行字符串拼接，并且调用 `to_string` 函数将 `age` 和 `score` 转换成了 `string`。

这里需要注意，一旦某个形参被定义了默认实参，那它后面的所有形参都必须有默认实参。也就是说，所有默认实参的指定，应该在形参列表的末尾。

调用赋值时，必须按照顺序依次赋值，不能跳过形参，如 `stuInfo(19)`，跳过了姓名，是不对的，可以改为 `stuInfo("zs", 19)`。

## 函数重载

在C++中，同一作用域下，同一个函数名可以定义多次，前提是形参列表不同。这种名字相同但形参列表不同的函数，叫做重载函数。这是C++相对C语言的重大改进，也是面向对象的基础。

### 定义重载函数

在上一章数组形参部分，我们曾经实现过几个不同的打印数组的函数，它们是可以同时存在的。

```c++
// 使用指针和长度作为形参
void printArr(const int *arr, int size)
{
    for (int i = 0; i < size; ++i)
    {
        cout << arr[i] << "\t";
    }
    cout << endl;
}

// 使用数组引用作为形参
void printArr(const int (&arr)[6])
{
    for (int num : arr)
    {
        cout << num << "\t";
    }
    cout << endl;
}
```

需要注意：
- 重载的函数，应该在形参的数量或者类型上有所不同；
- 形参的名称在类型中可以省略，所以只有形参名不同的函数是一样的；
- 调用函数时，编译器会根据传递的实参个数和类型，自动推断使用哪个函数；
- 主函数不能重载。

### 有 const 形参时的重载

当形参有 const 修饰时，要区分它对于实参的要求到底是什么，是否要进行值的拷贝。如果是传值参数，传入实参时会发生值的拷贝，那么实参是变量还是常量其实是没有区别的。

```c++
void fun(int x);

void fun(const int x);  // int 常量做形参，跟不加 const 等价

int i = 10;
const int ci = i; // 正确


void fun2(int *p); 
void fun2(int* const p); // 指针常量做形参，也跟不加 const 等价
```

这种情况下，`const` 不会影响传入函数的实参类型，所以跟不加 `const` 的定义是一样的，这叫做顶层 `const`。这时两个函数相同，无法进行函数重载。

另一种情况则不同，那就是传引用参数。这时如果有 `const` 修饰，就成了常量的引用，对于一个常量，只能用常量引用来绑定，而不能使用普通引用。

类似地，对于一个常量的地址，只能由指向常量的指针来指向它，而不能用普通指针。

```c++
void fun(int &x);
void fun(const int &x); // 形参类型是常量引用，这是一个新函数

void fun(int *p);
void fun(const int *p); // 形参类型是指向常量的指针，这是一个新函数

void fun(int *p);
void fun(const int *p);
```

这种情况下，`const` 限制了间接访问的数据对象是常量，这叫做底层 `const`。当实参是常量时，不能对不带 `const` 的引用进行初始化，所以只能调用常量引用做形参的函数，而如果实参是变量，就会优先匹配不带 `const` 的普通引用，这就实现了函数重载。

### 函数匹配

如果传入的实参跟形参类型不同，只要能通过隐式类型转换变成需要类型，函数也可以正确调用。那假如有几个不同的重载函数，它们的形参类型可以进行自动转换，这时传入实参应该调用哪个函数呢？例如：

```c++
void f();
void f(int x);
void f(int x, int y);
void f(double x, double y = 1.5);

f(3.14); // 应该调用哪个函数
```

确定到底调用哪个函数的过程叫做函数匹配。

1. 候选函数

函数匹配的第一步就是确定候选函数，也就是先找到对应的重载函数集。候选函数有两个要求：
- 与调用的函数同名；
- 函数的声明，在函数的调用点是可见的

所以上面的例子中，一共有4个叫做`f`的函数，它们都是候选函数。

2. 可行函数

接下来需要从候选函数中，选出跟传入的实参匹配的函数，这些函数叫做可行函数，可行函数也有两个要求：
- 形参个数与调用传入的实参数量相等；
- 每个实参的类型与对应形参的类型相同，或者可以转换成形参的类型。

上面的例子中，传入的实参只有一个，是一个 `double` 类型的字面值常量，所以可以排除 `f()` 和 `f(int, int)`。而剩下的 `f(int)` 和 `f(double, double = 1.5)` 都是匹配的，所以有 2 个可行函数。

3. 寻找最佳匹配

最后就是在可行函数中，选择最佳匹配。简单来说，实参类型与形参类型越接近匹配的越好。所以，能不进行转换就实际匹配的，要优于需要转换的。

上面的例子中，`f(int)` 必须要将 `double` 类型的实参转换成 `int`，而 `f(double, double = 1.5)` 不需要，所以后者是最佳匹配，最终调用的就是它。第二个参数会由默认实参 1.5 来填补。

4. 多参数的函数匹配

如果实参的数量不止一个，那么就需要逐个比较每个参数，同样，类型能够精确匹配的要优于需要转换的，这是寻找最佳匹配的原则如下：
- 如果可行函数的所有形参都能精确匹配实参，那么它就是最佳匹配
- 如果没有全部精确匹配，那么当一个可行函数所有参数的匹配，都不比别的可行函数差、并且至少有一个参数要更优，那它就是最佳匹配。

5. 二义性调用

如果检查所有实参之后，有多个可行函数不分优劣、无法找到一个最佳匹配，那么编译器会报错，这被称为二义性调用：

```c++
f(10, 3.14); // 二义性调用
```

这时的可行函数为 `f(int, int)` 和 `f(double, double = 1.5)`，第一个实参为 `int` 类型，`f(int, int)`占有，第二个实参为 `double` 类型，`f(double, double = 1.5)` 占优，这时两个可行函数分不出胜负，于是就会报二义性调用错误。


### 重载与作用域

重载是否生效，跟作用域是有关系的。如果在内存、外层作用域分别声明了同名的函数，那么内层作用域中的函数会覆盖外层的同名实体，让它隐藏起来。

不同的作用域中，是无法重载函数名的。

```c++
#include <iostream>

using namespace std;

void print(double d)
{
    cout << "d: " << d << endl;
}

void print(string s)
{
    cout << "s: " << s << endl;
}

int main()
{
    // 调用之前做函数声明
    void print(int i); // 此处的声明会覆盖外层的声明
    print(10);
    print(3.14); // 将3.14转换为3，然后调用
    print("hello"); // 错误，因为main函数内部的函数print声明覆盖了外面的重载函数
}
```

## 函数指针

一类特殊的指针，指向的不是数据对象而是函数，这就是函数指针。

### 声明函数指针

函数指针本质还是指针，它的类型和所指向的对象类型有关。现在指向的是函数，函数的类型由它返回类型和形参类型共同决定的，跟函数名、形参名都没有关系。例如

```c++
#include <iostream>
using namespace std;

string stuInfo(string name, int age, double score)
{
    string info = "name: " + name + "\t age: " + to_string(age) + "\t score: " + to_string(score);
    return info;
}
```

它的类型就是 `string(string, int, double)`.

如果要声明一个指向它的指针，只要把原先函数名的位置填上指针就可以了：

```c++
string (*fp) (string, int, double); // 一个函数指针
```

注意，这里指针两侧的括号不可少，如果去掉，就是表示一个函数，返回 `string *` 类型的函数：

```c++
string *fp (string, int, double); // 这是一个函数，返回值为指向 string 的指针
```

更加复杂的例子也是一样，例如：

```c++
const string& longerStr(const string &str1, const string &str2)
{
    return str1.size() > str2.size() ? str1 : str2;
}

// 对应类型的函数指针
const string &(*fp) (const string &, const string &);
```

### 使用函数指针

当一个函数名后面跟调用操作符（小括号），表示函数调用，而单独使用函数名作为一个值时，函数会自动转换成指针。这一点跟数组名类似。

所以可以直接使用函数名给函数指针赋值：

```c++
fp = longerStr; // 直接将函数名作为指针赋给 fp

// 也可以加上取地址符 &，这和不加 & 是等价的
fp = &longerStr; // 取地址符是可选的，和上面没有区别
```

赋值之后，就可以通过 `fp` 调用函数了。`fp` 做解引用可以得到函数，而这里解引用符 `*` 也是可选的，不做解引用同样可以直接表示函数。

```c++
cout << fp("hello", "world") << endl;

cout << (*fp)("hello", "world") << endl;
```

所以这里能够看出，函数指针完全可以当做函数来使用。

在对函数指针赋值时，函数的类型必须精确匹配。当然，函数指针也可以赋值 `nullptr`，表示空指针，没有指向任何一个函数。

### 函数指针作为形参

有了指向函数的指针，就给函数带来了更加丰富灵活的用法。比如，可以将函数指针作为形参，定义在另一个函数中，也就是说，可以定义一个函数，它以另一个函数类型作为形参。当然，函数本身不能作为形参，不过函数指针完美地填补了这个空缺。这一点上，函数跟数组非常类似。

```c++
void selectStr(const string &s1, const string &s2, const string &fp(const string&, const string&));

void selectStr(const sting &s1, const string &s2, const string &(*fp)(const string&, const string&));
```

同样地，上面两种形式是等价的，解引用符 `*` 是可选的。

很明显，对于函数类型和函数指针类型来说，这样的定义太过复杂，所以有必要使用 `typedef` 做一个类型别名的声明。

```c++
typedef const string& Func(const string&, const string&); // 函数类型
typedef const string& (*FuncP)(const string&, const string&); // 函数指针类型

// 函数指针形参简化为
void selectStr(const sting &s1, const string &s2, Func);
```

当然，还可以用 C++11 提供的 `decltype` 函数直接获取类型，更加简洁：

```c++
// 从某个函数提取函数类型
typedef decltype(longerStr) Func2;
typedef decltype(longerStr) *FuncP2;

// 然后约简函数指针作为形参
void selectStr(const sting &s1, const string &s2, Func2);
```

### 函数指针作为返回值

类似地，函数不能直接返回另一个函数，但是可以返回函数指针。所以可以将函数指针作为另一个函数的返回值。

这里需要注意，函数的返回类型必须是函数指针，而不能是函数类型：

```c++
typedef const string& Func(const string&, const string&); // 函数类型
typedef const string& (*FuncP)(const string&, const string&); // 函数指针类型

// or
typedef decltype(longerStr) Func;
typedef decltype(longerStr) *FuncP;

// 函数指针作为返回值
FuncP fun(int);

Func fun2(int); // 错误，不能直接返回函数
Func* fun2(int);

// 尾置返回类型
auto fun3(int) -> FuncP;
```

另外，可以使用尾置返回类型的方式，指定返回函数指针类型。

